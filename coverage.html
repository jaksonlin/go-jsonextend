
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>ast: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/jaksonlin/go-jsonextend/ast/ast.go (78.5%)</option>
				
				<option value="file1">github.com/jaksonlin/go-jsonextend/ast/ast_node.go (81.2%)</option>
				
				<option value="file2">github.com/jaksonlin/go-jsonextend/constructor/bytebase/ast.go (83.3%)</option>
				
				<option value="file3">github.com/jaksonlin/go-jsonextend/constructor/bytebase/astbuilder.go (85.0%)</option>
				
				<option value="file4">github.com/jaksonlin/go-jsonextend/constructor/bytebase/syntax.go (77.8%)</option>
				
				<option value="file5">github.com/jaksonlin/go-jsonextend/constructor/bytebase/tokenprovider.go (84.4%)</option>
				
				<option value="file6">github.com/jaksonlin/go-jsonextend/constructor/bytebase/utils.go (94.4%)</option>
				
				<option value="file7">github.com/jaksonlin/go-jsonextend/constructor/golang/ast.go (73.3%)</option>
				
				<option value="file8">github.com/jaksonlin/go-jsonextend/constructor/golang/astbuilder.go (86.4%)</option>
				
				<option value="file9">github.com/jaksonlin/go-jsonextend/constructor/golang/tokenprovider.go (56.2%)</option>
				
				<option value="file10">github.com/jaksonlin/go-jsonextend/constructor/golang/util.go (12.9%)</option>
				
				<option value="file11">github.com/jaksonlin/go-jsonextend/interpreter/err.go (0.0%)</option>
				
				<option value="file12">github.com/jaksonlin/go-jsonextend/interpreter/interpreter.go (90.8%)</option>
				
				<option value="file13">github.com/jaksonlin/go-jsonextend/interpreter/interpreterNoFormat.go (87.8%)</option>
				
				<option value="file14">github.com/jaksonlin/go-jsonextend/jsonextend.go (76.9%)</option>
				
				<option value="file15">github.com/jaksonlin/go-jsonextend/token/token.go (84.6%)</option>
				
				<option value="file16">github.com/jaksonlin/go-jsonextend/tokenizer/arraystate.go (72.7%)</option>
				
				<option value="file17">github.com/jaksonlin/go-jsonextend/tokenizer/booleanstate.go (75.0%)</option>
				
				<option value="file18">github.com/jaksonlin/go-jsonextend/tokenizer/err.go (0.0%)</option>
				
				<option value="file19">github.com/jaksonlin/go-jsonextend/tokenizer/factory.go (97.0%)</option>
				
				<option value="file20">github.com/jaksonlin/go-jsonextend/tokenizer/initstate.go (70.0%)</option>
				
				<option value="file21">github.com/jaksonlin/go-jsonextend/tokenizer/nullstate.go (75.0%)</option>
				
				<option value="file22">github.com/jaksonlin/go-jsonextend/tokenizer/numberstate.go (75.0%)</option>
				
				<option value="file23">github.com/jaksonlin/go-jsonextend/tokenizer/objectstate.go (81.8%)</option>
				
				<option value="file24">github.com/jaksonlin/go-jsonextend/tokenizer/state.go (80.0%)</option>
				
				<option value="file25">github.com/jaksonlin/go-jsonextend/tokenizer/statemachine.go (81.6%)</option>
				
				<option value="file26">github.com/jaksonlin/go-jsonextend/tokenizer/stringstate.go (80.0%)</option>
				
				<option value="file27">github.com/jaksonlin/go-jsonextend/tokenizer/tokenreader.go (100.0%)</option>
				
				<option value="file28">github.com/jaksonlin/go-jsonextend/tokenizer/variablestate.go (70.0%)</option>
				
				<option value="file29">github.com/jaksonlin/go-jsonextend/unmarshaler/err.go (0.0%)</option>
				
				<option value="file30">github.com/jaksonlin/go-jsonextend/unmarshaler/unmarshallOptions.go (68.8%)</option>
				
				<option value="file31">github.com/jaksonlin/go-jsonextend/unmarshaler/unmarshallResolver.go (87.8%)</option>
				
				<option value="file32">github.com/jaksonlin/go-jsonextend/unmarshaler/unmarshaller.go (80.6%)</option>
				
				<option value="file33">github.com/jaksonlin/go-jsonextend/util/char.go (58.8%)</option>
				
				<option value="file34">github.com/jaksonlin/go-jsonextend/util/stack.go (86.7%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package ast

// the idea is to maintain a stack holding element of JsonArrayNode, JsonObjectNode and JsonKeyValuePairNode
// any element in json is either `element in array` or `element in object`
// 1. element in array, create a JsonArrayNode, push it to the stack;
// when the value of this array comes, if it is primitive value push it into the JsonArrayNodes's value;
// for none-primitive value, create a new JsonArrayNode | JsonObjectNode and push it to the stack
// 2. element in object, create a JsonObjectNode, push it to the stack;
// the json object's value is maintained in a JsonKeyValuePairNode, when the value comes,
// when a create node operation comes and find that the top element is JsonObjectNode, create a JsonKeyValuePairNode and push it to the stack
// then put the value of the requested create node operation into the JsonKeyValuePairNode's `key` field.
// when the key-value pairs' value comes, if it is primitive value push it into the JsonKeyValuePairNode's `value` field;
// otherwise, create a new JsonArrayNode | JsonObjectNode and push it to the stack.
// once the JsonKeyValuePairNode's `value` field is set, finalize the JsonKeyValuePairNode and append it to the JsonObjectNode's value field
// when to finalize the JsonObjectNode? when the tokenizer finds a } | ] symbol, it will call the EncloseLatestElements() method
// this means that the current element is finished, so we need to pop the top element from the stack and put it into the owner element

import (
        "github.com/jaksonlin/go-jsonextend/util"
)

type astState uint

const (
        AST_STATE_INIT astState = iota
        AST_STATE_INTERMIDIEATE
        AST_STATE_FINISHED
)

type JsonextAST struct {
        ast      JsonNode
        astTrace *util.Stack[JsonNode]
        state    astState
}

func NewJsonextAST() *JsonextAST <span class="cov8" title="1">{
        return &amp;JsonextAST{
                ast:      nil,
                astTrace: util.NewStack[JsonNode](),
                state:    AST_STATE_INIT,
        }
}</span>

func (i *JsonextAST) GetAST() JsonNode <span class="cov8" title="1">{
        return i.ast
}</span>

func (i *JsonextAST) CreateRootNode(t AST_NODETYPE, value interface{}) error <span class="cov8" title="1">{
        n, err := NodeFactory(t, value)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">i.ast = n

        if t == AST_ARRAY || t == AST_OBJECT </span><span class="cov8" title="1">{
                i.astTrace.Push(n)
                i.state = AST_STATE_INTERMIDIEATE
        }</span> else<span class="cov8" title="1"> {
                i.state = AST_STATE_FINISHED
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (i *JsonextAST) CreateNewASTNode(t AST_NODETYPE, value interface{}) error <span class="cov8" title="1">{
        if i.state == AST_STATE_FINISHED </span><span class="cov0" title="0">{
                return ErrorASTComplete
        }</span>
        <span class="cov8" title="1">if i.ast == nil </span><span class="cov8" title="1">{
                return i.CreateRootNode(t, value)
        }</span>
        <span class="cov8" title="1">latest, err := i.astTrace.Peek()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">switch realNode := latest.(type) </span>{
        //stack have array at top, awaiting element
        case *JsonArrayNode:<span class="cov8" title="1">
                return i.CreateNewNodeForArrayObject(realNode, t, value)</span>
                // stack have object at top, awaiting kv pair node
        case *JsonObjectNode:<span class="cov8" title="1">
                return i.CreateNewNodeForObject(realNode, t, value)</span>
                // stack have kvpari at top, awaiting value node
        case *JsonKeyValuePairNode:<span class="cov8" title="1">
                return i.CreateValueNodeForKVPairs(realNode, t, value)</span>
        default:<span class="cov0" title="0">
                return ErrorASTUnexpectedElement</span>
        }

}

func (i *JsonextAST) CreateNewNodeForArrayObject(owner *JsonArrayNode, t AST_NODETYPE, value interface{}) error <span class="cov8" title="1">{
        n, err := NodeFactory(t, value)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if t == AST_ARRAY || t == AST_OBJECT </span><span class="cov8" title="1">{
                // none-primivtive value, create a new item to hold the furture values
                i.astTrace.Push(n)
        }</span> else<span class="cov8" title="1"> {
                // primitive value push to the owner on top of the stack
                owner.Append(n)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (i *JsonextAST) CreateNewNodeForObject(owner *JsonObjectNode, t AST_NODETYPE, value interface{}) error <span class="cov8" title="1">{
        keyNode, err := NodeFactory(t, value)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">n, err := NodeFactory(AST_KVPAIR, keyNode)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">i.astTrace.Push(n)
        return nil</span>
}

func (i *JsonextAST) CreateValueNodeForKVPairs(owner *JsonKeyValuePairNode, t AST_NODETYPE, value interface{}) error <span class="cov8" title="1">{

        n, err := NodeFactory(t, value)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // the value of the kv is array|object, push it on top of the stack
        <span class="cov8" title="1">if t == AST_ARRAY || t == AST_OBJECT </span><span class="cov8" title="1">{
                i.astTrace.Push(n)
        }</span> else<span class="cov8" title="1"> {
                // primivite value, finalize the k-v pair and append to the object node
                owner.Value = n
                err = i.FinlizeKVPair()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// 2 reason to finalise, enclose of kv pair due to `,`, enclose of kv pair due to `}`
// {"1":2,"3":4}
func (i *JsonextAST) FinlizeKVPair() error <span class="cov8" title="1">{
        kvElement, err := i.astTrace.Pop() // pop the kv, because it should be finalized to objet now.
        if err == util.ErrorEndOfStack </span><span class="cov0" title="0">{
                return ErrorASTStackEmpty
        }</span>
        <span class="cov8" title="1">if kvElement.GetNodeType() != AST_KVPAIR </span><span class="cov0" title="0">{
                return ErrorASTUnexpectedElement
        }</span>
        <span class="cov8" title="1">kvOwnerObj, err := i.astTrace.Peek()
        if err == util.ErrorEndOfStack </span><span class="cov0" title="0">{
                return ErrorASTStackEmpty
        }</span>
        <span class="cov8" title="1">if kvOwnerObj.GetNodeType() != AST_OBJECT </span><span class="cov0" title="0">{
                return ErrorASTUnexpectedElement
        }</span>
        <span class="cov8" title="1">el := kvOwnerObj.(*JsonObjectNode)
        el.Append(kvElement.(*JsonKeyValuePairNode))

        return nil</span>
}

func (i *JsonextAST) EncloseLatestElements() error <span class="cov8" title="1">{

        itemToFinalize, err := i.astTrace.Pop()
        if err == util.ErrorEndOfStack </span><span class="cov0" title="0">{
                i.state = AST_STATE_FINISHED
                return nil
        }</span>
        <span class="cov8" title="1">err = i.StoreFinlizedItemToOwner(itemToFinalize)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>

}

func (i *JsonextAST) TopElementType() (AST_NODETYPE, error) <span class="cov8" title="1">{
        t, err := i.astTrace.Peek()
        if err != nil </span><span class="cov0" title="0">{
                return AST_NODE_UNDEFINED, err
        }</span>
        <span class="cov8" title="1">return t.GetNodeType(), nil</span>
}

func (i *JsonextAST) StoreFinlizedItemToOwner(itemToFinalize JsonNode) error <span class="cov8" title="1">{
        nodeType := itemToFinalize.GetNodeType()
        switch nodeType </span>{
        case AST_OBJECT:<span class="cov8" title="1"> // item can only be value of kv or element of array
                fallthrough</span>
        case AST_ARRAY:<span class="cov8" title="1">
                ownerElement, err := i.astTrace.Peek()
                if err == util.ErrorEndOfStack </span><span class="cov8" title="1">{
                        i.state = AST_STATE_FINISHED
                        return nil // last element in the stack, no owner
                }</span>
                <span class="cov8" title="1">switch ownerElement.GetNodeType() </span>{
                case AST_ARRAY:<span class="cov8" title="1">
                        el := ownerElement.(*JsonArrayNode)
                        el.Append(itemToFinalize)</span> // array case, put it in array
                case AST_KVPAIR:<span class="cov8" title="1"> // kv case
                        el := ownerElement.(*JsonKeyValuePairNode)
                        el.Value = itemToFinalize
                        err = i.FinlizeKVPair()
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                default:<span class="cov0" title="0">
                        return ErrorASTUnexpectedOwnerElement</span>
                }
        default:<span class="cov0" title="0">
                return ErrorASTEncloseElementType</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (i *JsonextAST) HasOpenElement() bool <span class="cov8" title="1">{
        return i.astTrace.Length() &gt; 0
}</span>

func (i *JsonextAST) HasComplete() bool <span class="cov8" title="1">{
        return i.state == AST_STATE_FINISHED
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package ast

import (
        "encoding/base64"

        "github.com/jaksonlin/go-jsonextend/token"
        "github.com/jaksonlin/go-jsonextend/util"
)

type AST_NODETYPE byte

func (a AST_NODETYPE) Byte() byte <span class="cov8" title="1">{
        return byte(a)
}</span>

const (
        AST_NODE_TYPE_BOUNDARY AST_NODETYPE = 200
        AST_ARRAY              AST_NODETYPE = 201
        AST_OBJECT             AST_NODETYPE = 202
        AST_KVPAIR             AST_NODETYPE = 203
        AST_VARIABLE           AST_NODETYPE = 204
        AST_STRING_VARIABLE    AST_NODETYPE = 205
        AST_STRING             AST_NODETYPE = 206
        AST_NUMBER             AST_NODETYPE = 207
        AST_BOOLEAN            AST_NODETYPE = 208
        AST_NULL               AST_NODETYPE = 209
        AST_NODE_UNDEFINED     AST_NODETYPE = 210
)

func ConvertTokenTypeToNodeType(t token.TokenType) AST_NODETYPE <span class="cov0" title="0">{
        switch t </span>{
        case token.TOKEN_BOOLEAN:<span class="cov0" title="0">
                return AST_NUMBER</span>
        case token.TOKEN_STRING:<span class="cov0" title="0">
                return AST_STRING</span>
        case token.TOKEN_NUMBER:<span class="cov0" title="0">
                return AST_NUMBER</span>
        case token.TOKEN_NULL:<span class="cov0" title="0">
                return AST_NULL</span>
        case token.TOKEN_VARIABLE:<span class="cov0" title="0">
                return AST_VARIABLE</span>
        case token.TOKEN_STRING_WITH_VARIABLE:<span class="cov0" title="0">
                return AST_STRING_VARIABLE</span>
        default:<span class="cov0" title="0">
                return AST_NODE_UNDEFINED</span>
        }
}

func NodeFactory(t AST_NODETYPE, value interface{}) (JsonNode, error) <span class="cov8" title="1">{

        switch t </span>{
        case AST_ARRAY:<span class="cov8" title="1">
                return &amp;JsonArrayNode{
                        Value: make([]JsonNode, 0),
                }, nil</span>
        case AST_OBJECT:<span class="cov8" title="1">
                return &amp;JsonObjectNode{
                        Value: make([]*JsonKeyValuePairNode, 0),
                }, nil</span>
        case AST_KVPAIR:<span class="cov8" title="1">
                node, ok := value.(JsonStringValueNode)
                if !ok </span><span class="cov0" title="0">{
                        return nil, ErrorASTKeyValuePairNotStringAsKey
                }</span>
                <span class="cov8" title="1">return &amp;JsonKeyValuePairNode{
                        Key: node,
                }, nil</span>
        case AST_STRING:<span class="cov8" title="1">
                return &amp;JsonStringNode{
                        Value: value.([]byte),
                }, nil</span>
        case AST_NUMBER:<span class="cov8" title="1">
                return &amp;JsonNumberNode{
                        Value: value.(float64),
                }, nil</span>
        case AST_BOOLEAN:<span class="cov8" title="1">
                return &amp;JsonBooleanNode{
                        Value: value.(bool),
                }, nil</span>
        case AST_NULL:<span class="cov8" title="1">
                return &amp;JsonNullNode{
                        Value: nil,
                }, nil</span>
        case AST_VARIABLE:<span class="cov8" title="1">
                node := &amp;JsonExtendedVariableNode{
                        Value: value.([]byte),
                }
                node.extractVariable()
                return node, nil</span>
        case AST_STRING_VARIABLE:<span class="cov8" title="1">
                node := &amp;JsonExtendedStringWIthVariableNode{
                        JsonStringNode: JsonStringNode{
                                Value: value.([]byte),
                        },
                }
                node.extractVariables()
                return node, nil</span>
        default:<span class="cov0" title="0">
                return nil, ErrorASTIncorrectNodeType</span>
        }
}

type JsonVisitor interface {
        VisitStringNode(node *JsonStringNode) error
        VisitNumberNode(node *JsonNumberNode) error
        VisitBooleanNode(node *JsonBooleanNode) error
        VisitNullNode(node *JsonNullNode) error
        VisitArrayNode(node *JsonArrayNode) error
        VisitKeyValuePairNode(node *JsonKeyValuePairNode) error
        VisitObjectNode(node *JsonObjectNode) error
        VisitVariableNode(node *JsonExtendedVariableNode) error
        VisitStringWithVariableNode(node *JsonExtendedStringWIthVariableNode) error
}

type JsonNode interface {
        GetNodeType() AST_NODETYPE
        Visit(visitor JsonVisitor) error
}

type JsonCollectionNode interface {
        JsonNode
        Length() int
}

type JsonStringValueNode interface {
        JsonNode
        GetValue() string
}

type JsonStringNode struct {
        Value []byte
}

var _ JsonNode = &amp;JsonStringNode{}

func (node *JsonStringNode) GetNodeType() AST_NODETYPE <span class="cov8" title="1">{
        return AST_STRING
}</span>

func (node *JsonStringNode) Visit(visitor JsonVisitor) error <span class="cov8" title="1">{
        return visitor.VisitStringNode(node)
}</span>

func (node *JsonStringNode) GetValue() string <span class="cov8" title="1">{
        if len(node.Value) == 2 </span><span class="cov8" title="1">{
                return "" // empty string with 2 double quotation marks only
        }</span> else<span class="cov8" title="1"> {
                return string(node.Value[1 : len(node.Value)-1])
        }</span>
}

func (node *JsonStringNode) ToArrayNode() (*JsonArrayNode, error) <span class="cov8" title="1">{

        data, err := base64.StdEncoding.DecodeString(node.GetValue())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">rs := &amp;JsonArrayNode{
                Value: make([]JsonNode, 0, len(data)),
        }
        for _, n := range data </span><span class="cov8" title="1">{
                v := uint8(n)
                rs.Value = append(rs.Value, &amp;JsonNumberNode{
                        Value: float64(v),
                })
        }</span>
        <span class="cov8" title="1">return rs, nil</span>

}

type JsonNumberNode struct {
        Value float64
}

var _ JsonNode = &amp;JsonNumberNode{}

func (node *JsonNumberNode) GetNodeType() AST_NODETYPE <span class="cov8" title="1">{
        return AST_NUMBER
}</span>

func (node *JsonNumberNode) Visit(visitor JsonVisitor) error <span class="cov8" title="1">{
        return visitor.VisitNumberNode(node)
}</span>

type JsonBooleanNode struct {
        Value bool
}

var _ JsonNode = &amp;JsonBooleanNode{}

func (node *JsonBooleanNode) GetNodeType() AST_NODETYPE <span class="cov8" title="1">{
        return AST_BOOLEAN
}</span>

func (node *JsonBooleanNode) Visit(visitor JsonVisitor) error <span class="cov8" title="1">{
        return visitor.VisitBooleanNode(node)
}</span>

type JsonNullNode struct {
        Value interface{}
}

var _ JsonNode = &amp;JsonNullNode{}

func (node *JsonNullNode) GetNodeType() AST_NODETYPE <span class="cov8" title="1">{
        return AST_NULL
}</span>

func (node *JsonNullNode) Visit(visitor JsonVisitor) error <span class="cov8" title="1">{
        return visitor.VisitNullNode(node)
}</span>

type JsonArrayNode struct {
        Value []JsonNode
}

var _ JsonNode = &amp;JsonArrayNode{}

func (node *JsonArrayNode) GetNodeType() AST_NODETYPE <span class="cov8" title="1">{
        return AST_ARRAY
}</span>

func (node *JsonArrayNode) Visit(visitor JsonVisitor) error <span class="cov8" title="1">{
        return visitor.VisitArrayNode(node)
}</span>

func (node *JsonArrayNode) Append(n JsonNode) <span class="cov8" title="1">{
        node.Value = append(node.Value, n)
}</span>

func (node *JsonArrayNode) Length() int <span class="cov8" title="1">{
        return len(node.Value)
}</span>

type JsonKeyValuePairNode struct {
        Key   JsonStringValueNode
        Value JsonNode
}

var _ JsonNode = &amp;JsonKeyValuePairNode{}

func (node *JsonKeyValuePairNode) GetNodeType() AST_NODETYPE <span class="cov8" title="1">{
        return AST_KVPAIR
}</span>

func (node *JsonKeyValuePairNode) Visit(visitor JsonVisitor) error <span class="cov8" title="1">{
        return visitor.VisitKeyValuePairNode(node)
}</span>

func (node *JsonKeyValuePairNode) IsFilled() bool <span class="cov0" title="0">{
        return node.Value != nil
}</span>

type JsonObjectNode struct {
        Value []*JsonKeyValuePairNode
}

var _ JsonNode = &amp;JsonObjectNode{}

func (node *JsonObjectNode) GetNodeType() AST_NODETYPE <span class="cov8" title="1">{
        return AST_OBJECT
}</span>

func (node *JsonObjectNode) Visit(visitor JsonVisitor) error <span class="cov8" title="1">{
        return visitor.VisitObjectNode(node)
}</span>

func (node *JsonObjectNode) Append(kvNode *JsonKeyValuePairNode) <span class="cov8" title="1">{
        node.Value = append(node.Value, kvNode)
}</span>

func (node *JsonObjectNode) Length() int <span class="cov0" title="0">{
        return len(node.Value)
}</span>

type JsonExtendedVariableNode struct {
        Value    []byte
        Variable string
}

var _ JsonNode = &amp;JsonExtendedVariableNode{}

func (node *JsonExtendedVariableNode) GetNodeType() AST_NODETYPE <span class="cov8" title="1">{
        return AST_VARIABLE
}</span>

func (node *JsonExtendedVariableNode) Visit(visitor JsonVisitor) error <span class="cov8" title="1">{
        return visitor.VisitVariableNode(node)
}</span>

func (node *JsonExtendedVariableNode) extractVariable() <span class="cov8" title="1">{
        rs := util.RegStringWithVariable.FindSubmatch(node.Value)
        node.Variable = string(rs[1])
}</span>

type JsonExtendedStringWIthVariableNode struct {
        JsonStringNode
        Variables map[string][]byte
}

var _ JsonNode = &amp;JsonExtendedStringWIthVariableNode{}

func (node *JsonExtendedStringWIthVariableNode) GetNodeType() AST_NODETYPE <span class="cov8" title="1">{
        return AST_STRING_VARIABLE
}</span>

func (node *JsonExtendedStringWIthVariableNode) Visit(visitor JsonVisitor) error <span class="cov8" title="1">{
        return visitor.VisitStringWithVariableNode(node)
}</span>

func (node *JsonExtendedStringWIthVariableNode) extractVariables() <span class="cov8" title="1">{
        rs := util.RegStringWithVariable.FindAllSubmatch(node.Value, -1)
        if len(rs) &gt; 0 </span><span class="cov8" title="1">{
                node.Variables = make(map[string][]byte)
        }</span>
        <span class="cov8" title="1">for _, item := range rs </span><span class="cov8" title="1">{
                node.Variables[string(item[1])] = item[0]
        }</span>
}

func (node *JsonExtendedStringWIthVariableNode) GetValue() string <span class="cov8" title="1">{
        return node.JsonStringNode.GetValue()
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package bytebase

import (
        "github.com/jaksonlin/go-jsonextend/ast"
        "github.com/jaksonlin/go-jsonextend/constructor"
        "github.com/jaksonlin/go-jsonextend/token"
)

type astByteBaseConstructor struct {
        ast           *ast.JsonextAST
        syntaxChecker *syntaxChecker
}

var _ constructor.ASTManager = &amp;astByteBaseConstructor{}

func newASTConstructor() *astByteBaseConstructor <span class="cov8" title="1">{
        return &amp;astByteBaseConstructor{
                ast:           ast.NewJsonextAST(),
                syntaxChecker: newSyntaxChecker(),
        }
}</span>

// when a json symbol is read, push it to syntax checker and construct the AST stack elements (as described in ast.go)
func (i *astByteBaseConstructor) RecordSyntaxSymbol(b token.TokenType) error <span class="cov8" title="1">{
        //routing base on symbol
        switch b </span>{
        case token.TOKEN_LEFT_BRACE:<span class="cov8" title="1">
                i.syntaxChecker.PushSymbol('{')
                return i.ast.CreateNewASTNode(ast.AST_OBJECT, nil)</span>
        case token.TOKEN_LEFT_BRACKET:<span class="cov8" title="1">
                i.syntaxChecker.PushSymbol('[')
                return i.ast.CreateNewASTNode(ast.AST_ARRAY, nil)</span>
        case token.TOKEN_RIGHT_BRACKET:<span class="cov8" title="1">
                i.syntaxChecker.PushSymbol(']')
                // check syntax before manipulate the AST
                err := i.syntaxChecker.Enclose(']')
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">err = i.ast.EncloseLatestElements()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        case token.TOKEN_RIGHT_BRACE:<span class="cov8" title="1">
                i.syntaxChecker.PushSymbol('}')
                // check syntax before manipulate the AST
                err := i.syntaxChecker.Enclose('}')
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">err = i.ast.EncloseLatestElements()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        case token.TOKEN_COLON:<span class="cov8" title="1">
                i.syntaxChecker.PushSymbol(':')</span>
        case token.TOKEN_COMMA:<span class="cov8" title="1">
                i.syntaxChecker.PushSymbol(',')</span>
        default:<span class="cov0" title="0">
                return ErrorIncorrectSyntaxSymbolForConstructAST</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (i *astByteBaseConstructor) RecordStateValue(valueType ast.AST_NODETYPE, nodeValue interface{}) error <span class="cov8" title="1">{
        i.syntaxChecker.PushValue(valueType)
        return i.ast.CreateNewASTNode(valueType, nodeValue)
}</span>

func (i *astByteBaseConstructor) GetAST() ast.JsonNode <span class="cov8" title="1">{
        return i.ast.GetAST()
}</span>

func (i *astByteBaseConstructor) HasComplete() bool <span class="cov8" title="1">{
        return i.ast.HasComplete()
}</span>

func (i *astByteBaseConstructor) TopElementType() (ast.AST_NODETYPE, error) <span class="cov8" title="1">{
        return i.ast.TopElementType()
}</span>

func (i *astByteBaseConstructor) HasOpenElements() bool <span class="cov8" title="1">{
        return i.ast.HasOpenElement()
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package bytebase

import (
        "io"

        "github.com/jaksonlin/go-jsonextend/ast"
        "github.com/jaksonlin/go-jsonextend/constructor"
        "github.com/jaksonlin/go-jsonextend/token"
)

type ASTByteBaseBuilder struct {
        astConstructor *astByteBaseConstructor
        provider       *tokenProvider
}

func NewASTByteBaseBuilder(reader io.Reader) *ASTByteBaseBuilder <span class="cov8" title="1">{
        return &amp;ASTByteBaseBuilder{
                astConstructor: newASTConstructor(),
                provider:       newTokenProvider(reader),
        }
}</span>

var _ constructor.ASTBuilder = &amp;ASTByteBaseBuilder{}

// put the store to syntax symbol here, to decouple the relation of reader and writer
func (t *ASTByteBaseBuilder) GetNextTokenType() (token.TokenType, error) <span class="cov8" title="1">{

        nextTokenType, err := t.provider.GetNextTokenType()
        if err != nil </span><span class="cov0" title="0">{
                return token.TOKEN_DUMMY, err
        }</span>

        <span class="cov8" title="1">if token.IsSymbolToken(nextTokenType) </span><span class="cov8" title="1">{ // note symbol token will be parse in the corresponding primitive value state
                err = t.astConstructor.RecordSyntaxSymbol(nextTokenType)
                if err != nil </span><span class="cov0" title="0">{
                        return token.TOKEN_DUMMY, err
                }</span>
        }

        <span class="cov8" title="1">return nextTokenType, nil</span>
}

func (t *ASTByteBaseBuilder) ReadBool() (bool, error) <span class="cov8" title="1">{
        return t.provider.ReadBool()
}</span>
func (t *ASTByteBaseBuilder) ReadNull() error <span class="cov8" title="1">{
        return t.provider.ReadNull()
}</span>

func (t *ASTByteBaseBuilder) ReadNumber() (float64, error) <span class="cov8" title="1">{
        return t.provider.ReadNumber()
}</span>

func (t *ASTByteBaseBuilder) ReadString() ([]byte, error) <span class="cov8" title="1">{
        return t.provider.ReadString()
}</span>

func (t *ASTByteBaseBuilder) ReadVariable() ([]byte, error) <span class="cov8" title="1">{
        return t.provider.ReadVariable()
}</span>

func (t *ASTByteBaseBuilder) RecordSyntaxSymbol(b token.TokenType) error <span class="cov0" title="0">{
        return t.astConstructor.RecordSyntaxSymbol(b)
}</span>

func (t *ASTByteBaseBuilder) RecordStateValue(valueType ast.AST_NODETYPE, nodeValue interface{}) error <span class="cov8" title="1">{
        return t.astConstructor.RecordStateValue(valueType, nodeValue)
}</span>

func (i *ASTByteBaseBuilder) GetAST() ast.JsonNode <span class="cov8" title="1">{
        return i.astConstructor.GetAST()
}</span>

func (i *ASTByteBaseBuilder) HasComplete() bool <span class="cov8" title="1">{
        return i.astConstructor.HasComplete()
}</span>

func (i *ASTByteBaseBuilder) TopElementType() (ast.AST_NODETYPE, error) <span class="cov8" title="1">{
        return i.astConstructor.TopElementType()
}</span>

func (i *ASTByteBaseBuilder) HasOpenElements() bool <span class="cov8" title="1">{
        return i.astConstructor.HasOpenElements()
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package bytebase

import (
        "github.com/jaksonlin/go-jsonextend/ast"
        "github.com/jaksonlin/go-jsonextend/util"
)

type syntaxChecker struct {
        syntaxState *util.Stack[byte]
        length      int
}

func newSyntaxChecker() *syntaxChecker <span class="cov8" title="1">{
        return &amp;syntaxChecker{
                syntaxState: &amp;util.Stack[byte]{},
                length:      0,
        }
}</span>

func (s *syntaxChecker) PushSymbol(b byte) <span class="cov8" title="1">{
        s.syntaxState.Push(b)
        s.length += 1
}</span>

func (s *syntaxChecker) PushValue(val ast.AST_NODETYPE) <span class="cov8" title="1">{
        s.syntaxState.Push(byte(val))
        s.length += 1
}</span>

func (s *syntaxChecker) Length() int <span class="cov0" title="0">{
        return s.length
}</span>

func (s *syntaxChecker) Enclose(b byte) error <span class="cov8" title="1">{

        t, err := s.syntaxState.Pop()
        if err == util.ErrorEndOfStack </span><span class="cov0" title="0">{
                return ErrorSyntaxEmptyStack
        }</span>
        <span class="cov8" title="1">if t &gt; ast.AST_NODE_TYPE_BOUNDARY.Byte() </span><span class="cov0" title="0">{
                return ErrorSyntaxEncloseIncorrectSymbol
        }</span>
        <span class="cov8" title="1">if t != b </span><span class="cov0" title="0">{
                return ErrorSyntaxEncloseSymbolNotMatch
        }</span>
        <span class="cov8" title="1">if t == ']' </span><span class="cov8" title="1">{
                return s.jsonArrayFormatCheck()
        }</span> else<span class="cov8" title="1"> if t == '}' </span><span class="cov8" title="1">{
                return s.jsonObjectCheck()
        }</span> else<span class="cov0" title="0"> {
                return ErrorSyntaxEncloseSymbolIncorrect
        }</span>
}

func (s *syntaxChecker) jsonArrayFormatCheck() error <span class="cov8" title="1">{
        expectingValue := true
        lastIsValue := false
        hasEncounterValue := false
        for </span><span class="cov8" title="1">{
                t, err := s.syntaxState.Pop()
                if err == util.ErrorEndOfStack </span><span class="cov0" title="0">{
                        return ErrorSyntaxEmptyStack
                }</span>
                <span class="cov8" title="1">if t == '[' </span><span class="cov8" title="1">{
                        if hasEncounterValue &amp;&amp; !lastIsValue </span><span class="cov0" title="0">{ // deal with [] | [,], the previous is ok hasNeverEncounterValue by pass to ok, later raise error
                                return ErrorSyntaxCommaBehindLastItem
                        }</span>
                        // mark that here is an array in the syntax checker
                        <span class="cov8" title="1">s.syntaxState.Push(ast.AST_ARRAY.Byte())
                        return nil</span>
                }
                <span class="cov8" title="1">if expectingValue </span><span class="cov8" title="1">{ // ascii symbol
                        if t &lt; ast.AST_NODE_TYPE_BOUNDARY.Byte() </span><span class="cov0" title="0">{
                                return ErrorSyntaxElementNotSeparatedByComma
                        }</span> else<span class="cov8" title="1"> {
                                lastIsValue = true
                                hasEncounterValue = true
                        }</span>
                } else<span class="cov8" title="1"> if !expectingValue </span><span class="cov8" title="1">{
                        if t &gt; ast.AST_NODE_TYPE_BOUNDARY.Byte() </span><span class="cov0" title="0">{
                                return ErrorSyntaxElementNotSeparatedByComma
                        }</span>
                        <span class="cov8" title="1">if t != 0x2C </span><span class="cov0" title="0">{
                                return ErrorSyntaxUnexpectedSymbolInArray
                        }</span>
                        <span class="cov8" title="1">lastIsValue = false</span>
                }
                <span class="cov8" title="1">expectingValue = !expectingValue</span>

        }
}

func (s *syntaxChecker) jsonObjectCheck() error <span class="cov8" title="1">{
        expectingValue := true // already pop the } | ]
        lastIsValue := false
        hasEncounterValue := false
        expectingSymbol := byte(':') // first symbol to expect is : then , then : then , ...
        for </span><span class="cov8" title="1">{
                t, err := s.syntaxState.Pop()
                if err == util.ErrorEndOfStack </span><span class="cov0" title="0">{
                        return ErrorSyntaxEmptyStack
                }</span>
                // check first otherwise drop into compare with allowed symbol
                <span class="cov8" title="1">if t == '{' </span><span class="cov8" title="1">{
                        if hasEncounterValue &amp;&amp; !lastIsValue </span><span class="cov0" title="0">{
                                return ErrorSyntaxCommaBehindLastItem
                        }</span>
                        // enclose the object as a value in the syntax checker, this will save our hands in handling }} or ]} in the syntax checker
                        // this will collapse the checking of symbol into: always having symbol in between the value (braces and brakcets are collpased into value)
                        // in our design, the array and object will be collapse into syntax_value, []{}
                        <span class="cov8" title="1">s.syntaxState.Push(ast.AST_OBJECT.Byte())
                        return nil</span>
                }
                <span class="cov8" title="1">if expectingValue </span><span class="cov8" title="1">{
                        // expecting value but find symbol
                        if t &lt; ast.AST_NODE_TYPE_BOUNDARY.Byte() </span><span class="cov0" title="0">{
                                return ErrorSyntaxElementNotSeparatedByComma
                        }</span> else<span class="cov8" title="1"> {
                                // the json key's previous symbol is either `{` or `,`, that means in the stack's next pop, if it is a ',' then this AST_STRING_vARIABLE is a json-key
                                // which is invalid, because people may put arbitrary variable as key which may break the json format
                                if t == ast.AST_VARIABLE.Byte() &amp;&amp; expectingSymbol == ',' </span><span class="cov0" title="0">{
                                        return ErrorSyntaxExtendedSyntaxVariableAsKey
                                }</span>
                                <span class="cov8" title="1">lastIsValue = true
                                hasEncounterValue = true</span>
                        }
                } else<span class="cov8" title="1"> if !expectingValue </span><span class="cov8" title="1">{
                        if t &gt; ast.AST_NODE_TYPE_BOUNDARY.Byte() </span><span class="cov0" title="0">{
                                return ErrorSyntaxElementNotSeparatedByComma
                        }</span>
                        <span class="cov8" title="1">if t != expectingSymbol </span><span class="cov0" title="0">{
                                return ErrorSyntaxObjectSymbolNotMatch
                        }</span>
                        // switch the symbol to expect, if expectingSymbol is : then next is , and vice versa
                        <span class="cov8" title="1">if expectingSymbol == ':' </span><span class="cov8" title="1">{
                                expectingSymbol = ','
                        }</span> else<span class="cov8" title="1"> {
                                expectingSymbol = ':'
                        }</span>
                        <span class="cov8" title="1">lastIsValue = false</span>
                }
                <span class="cov8" title="1">expectingValue = !expectingValue</span>

        }
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package bytebase

import (
        "bufio"
        "io"
        "strconv"

        "github.com/jaksonlin/go-jsonextend/constructor"
        "github.com/jaksonlin/go-jsonextend/token"
)

type tokenProvider struct {
        dataSource     *bufio.Reader
        CurrentOffset  int
        LastReadLength int // this can give us the correct startoffset of current element
}

func newTokenProvider(reader io.Reader) *tokenProvider <span class="cov8" title="1">{
        return &amp;tokenProvider{
                dataSource: bufio.NewReader(reader),
        }
}</span>

var _ constructor.TokenProvider = &amp;tokenProvider{}

func (t *tokenProvider) ReadBool() (bool, error) <span class="cov8" title="1">{
        // in boolean state we will consume until it is the end of boolean.
        data, err := t.dataSource.Peek(1)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov8" title="1">numberOfRead := 0
        if data[0] == 't' </span><span class="cov8" title="1">{
                numberOfRead = 4
        }</span> else<span class="cov8" title="1"> if data[0] == 'f' </span><span class="cov8" title="1">{
                numberOfRead = 5
        }</span> else<span class="cov0" title="0"> {
                return false, ErrorIncorrectCharacter
        }</span>

        <span class="cov8" title="1">rs := make([]byte, numberOfRead)

        _, err = io.ReadFull(t.dataSource, rs)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov8" title="1">t.LastReadLength = numberOfRead
        t.CurrentOffset += t.LastReadLength

        rsBoolean, err := strconv.ParseBool(string(rs))
        if err != nil </span><span class="cov0" title="0">{
                return false, ErrorIncorrectValueForState
        }</span>
        <span class="cov8" title="1">return rsBoolean, nil</span>
}

func (t *tokenProvider) GetNextTokenType() (token.TokenType, error) <span class="cov8" title="1">{

        nextByte, err := t.dataSource.ReadByte()
        if err != nil </span><span class="cov0" title="0">{
                return token.TOKEN_DUMMY, err
        }</span>

        <span class="cov8" title="1">nextTokenType := GetTokenTypeByStartCharacter(nextByte)

        if ShouldUnreadByte(nextTokenType) </span><span class="cov8" title="1">{
                err = t.dataSource.UnreadByte()
                if err != nil </span><span class="cov0" title="0">{
                        return token.TOKEN_DUMMY, err
                }</span>
        } else<span class="cov8" title="1"> {
                t.LastReadLength = 1
                t.CurrentOffset += t.LastReadLength
        }</span>

        <span class="cov8" title="1">return nextTokenType, nil</span>
}

func (t *tokenProvider) ReadNull() error <span class="cov8" title="1">{
        rs := make([]byte, 4)
        _, err := io.ReadFull(t.dataSource, rs)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">t.LastReadLength = 4
        t.CurrentOffset += t.LastReadLength
        if string(rs) != "null" </span><span class="cov0" title="0">{
                return ErrorIncorrectValueForState
        }</span>
        <span class="cov8" title="1">return nil</span>

}

func (t *tokenProvider) ReadNumber() (float64, error) <span class="cov8" title="1">{
        lengthOfNumber := 1
        for </span><span class="cov8" title="1">{
                nextByte, err := t.dataSource.Peek(lengthOfNumber)
                if err != nil </span><span class="cov8" title="1">{
                        if err != io.EOF </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov8" title="1">lengthOfNumber -= 1
                        //bare number
                        break</span>
                }
                <span class="cov8" title="1">if !isJSONNumberByte(nextByte[lengthOfNumber-1]) </span><span class="cov8" title="1">{
                        lengthOfNumber -= 1 // remove the invalid location
                        break</span>
                }
                <span class="cov8" title="1">lengthOfNumber += 1</span>
        }

        <span class="cov8" title="1">result := make([]byte, lengthOfNumber)
        _, err := io.ReadFull(t.dataSource, result)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">t.LastReadLength = lengthOfNumber
        t.CurrentOffset += t.LastReadLength
        f64, err := strconv.ParseFloat(string(result), 64)
        if err != nil </span><span class="cov0" title="0">{
                return 0, ErrorIncorrectValueForState
        }</span>
        <span class="cov8" title="1">return f64, nil</span>
}

func (t *tokenProvider) ReadString() ([]byte, error) <span class="cov8" title="1">{

        // in order to deal with the multiple slash/escape sequence, we need a flag to check the string state
        isSlashEnclosed := true
        stringLength := 1
        validQuotationCount := 0
        for </span><span class="cov8" title="1">{
                nextByte, err := t.dataSource.Peek(stringLength)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // slashes are closed
                <span class="cov8" title="1">if isSlashEnclosed </span><span class="cov8" title="1">{
                        // is double quotation mark, end of string
                        if nextByte[stringLength-1] == '"' </span><span class="cov8" title="1">{
                                validQuotationCount += 1
                                if validQuotationCount == 2 </span><span class="cov8" title="1">{
                                        rs := make([]byte, stringLength)
                                        _, err := io.ReadFull(t.dataSource, rs)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return nil, err
                                        }</span>
                                        <span class="cov8" title="1">t.LastReadLength = stringLength
                                        t.CurrentOffset += t.LastReadLength
                                        return rs, nil</span>
                                }
                        } else<span class="cov8" title="1"> if nextByte[stringLength-1] == 0x5c </span><span class="cov8" title="1">{ // is slash
                                isSlashEnclosed = false
                        }</span>
                } else<span class="cov8" title="1"> {
                        isSlashEnclosed = true // flip the slash when there's nextByte, in escape mode skip quotation count check
                }</span>
                <span class="cov8" title="1">stringLength += 1</span>

        }
}

func (t *tokenProvider) ReadVariable() ([]byte, error) <span class="cov8" title="1">{
        variable, err := t.dataSource.ReadBytes('}')
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">t.LastReadLength = len(variable)
        t.CurrentOffset += t.LastReadLength
        return variable, nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package bytebase

import (
        "github.com/jaksonlin/go-jsonextend/token"
        "github.com/jaksonlin/go-jsonextend/util"
)

// in json k-v start bytes
func GetTokenTypeByStartCharacter(b byte) token.TokenType <span class="cov8" title="1">{
        switch </span>{
        case util.IsNumberStartingCharacter(b):<span class="cov8" title="1">
                return token.TOKEN_NUMBER</span>
        case b == '"':<span class="cov8" title="1">
                return token.TOKEN_STRING</span>
        case b == 't' || b == 'f':<span class="cov8" title="1">
                return token.TOKEN_BOOLEAN</span>
        case b == 'n':<span class="cov8" title="1">
                return token.TOKEN_NULL</span>
        case b == '$':<span class="cov8" title="1">
                return token.TOKEN_VARIABLE</span>
        case b == '{':<span class="cov8" title="1">
                return token.TOKEN_LEFT_BRACE</span>
        case b == '[':<span class="cov8" title="1">
                return token.TOKEN_LEFT_BRACKET</span>
        case b == '}':<span class="cov8" title="1">
                return token.TOKEN_RIGHT_BRACE</span>
        case b == ']':<span class="cov8" title="1">
                return token.TOKEN_RIGHT_BRACKET</span>
        case b == ':':<span class="cov8" title="1">
                return token.TOKEN_COLON</span>
        case b == ',':<span class="cov8" title="1">
                return token.TOKEN_COMMA</span>
        case util.IsSpaces(b):<span class="cov8" title="1">
                return token.TOKEN_SPACE</span>
        default:<span class="cov0" title="0">
                return token.TOKEN_DROP</span>
        }
}

// these symbols should be unread to buffer, they are read first to determine the state change,
// not using peek to collect them because there may be a long way to go till we see it.
func ShouldUnreadByte(t token.TokenType) bool <span class="cov8" title="1">{
        switch t </span>{
        case token.TOKEN_BOOLEAN:<span class="cov8" title="1"></span>
        case token.TOKEN_NUMBER:<span class="cov8" title="1"></span>
        case token.TOKEN_STRING:<span class="cov8" title="1"></span>
        case token.TOKEN_NULL:<span class="cov8" title="1"></span>
        case token.TOKEN_VARIABLE:<span class="cov8" title="1"></span>
        default:<span class="cov8" title="1"> // unread value for value mode
                return false</span>
        }
        <span class="cov8" title="1">return true</span>
}

func isJSONNumberByte(b byte) bool <span class="cov8" title="1">{
        return (b &gt;= '0' &amp;&amp; b &lt;= '9') || b == '-' || b == '.' || b == 'e' || b == 'E' || b == '+'
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package golang

import (
        "github.com/jaksonlin/go-jsonextend/ast"
        "github.com/jaksonlin/go-jsonextend/constructor"
        "github.com/jaksonlin/go-jsonextend/token"
)

type astGolangConstructor struct {
        ast *ast.JsonextAST
}

var _ constructor.ASTManager = &amp;astGolangConstructor{}

func newASTConstructor() *astGolangConstructor <span class="cov8" title="1">{
        return &amp;astGolangConstructor{
                ast: ast.NewJsonextAST(),
        }
}</span>

// when a json symbol is read, push it to syntax checker and construct the AST stack elements (as described in ast.go)
func (i *astGolangConstructor) RecordSyntaxSymbol(b token.TokenType) error <span class="cov8" title="1">{
        //routing base on symbol
        switch b </span>{
        case token.TOKEN_LEFT_BRACE:<span class="cov8" title="1">
                return i.ast.CreateNewASTNode(ast.AST_OBJECT, nil)</span>
        case token.TOKEN_LEFT_BRACKET:<span class="cov0" title="0">
                return i.ast.CreateNewASTNode(ast.AST_ARRAY, nil)</span>
        case token.TOKEN_RIGHT_BRACKET:<span class="cov0" title="0">
                fallthrough</span>
        case token.TOKEN_RIGHT_BRACE:<span class="cov8" title="1">
                err := i.ast.EncloseLatestElements()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        default:<span class="cov0" title="0">
                return ErrorIncorrectSyntaxSymbolForConstructAST</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (i *astGolangConstructor) RecordStateValue(valueType ast.AST_NODETYPE, nodeValue interface{}) error <span class="cov8" title="1">{
        return i.ast.CreateNewASTNode(valueType, nodeValue)
}</span>

func (i *astGolangConstructor) GetAST() ast.JsonNode <span class="cov8" title="1">{
        return i.ast.GetAST()
}</span>

func (i *astGolangConstructor) HasComplete() bool <span class="cov8" title="1">{
        return i.ast.HasComplete()
}</span>

func (i *astGolangConstructor) TopElementType() (ast.AST_NODETYPE, error) <span class="cov8" title="1">{
        return i.ast.TopElementType()
}</span>

func (i *astGolangConstructor) HasOpenElements() bool <span class="cov8" title="1">{
        return i.ast.HasOpenElement()
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package golang

import (
        "github.com/jaksonlin/go-jsonextend/ast"
        "github.com/jaksonlin/go-jsonextend/constructor"
        "github.com/jaksonlin/go-jsonextend/token"
)

type ASTGolangBaseBuilder struct {
        astConstructor *astGolangConstructor
        provider       *tokenProvider
}

func NewASTGolangBaseBuilder(obj interface{}) (constructor.ASTBuilder, error) <span class="cov8" title="1">{
        provider, err := newTokenProvider(obj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;ASTGolangBaseBuilder{
                astConstructor: newASTConstructor(),
                provider:       provider,
        }, nil</span>
}

var _ constructor.ASTBuilder = &amp;ASTGolangBaseBuilder{}

// put the store to syntax symbol here, to decouple the relation of reader and writer
func (t *ASTGolangBaseBuilder) GetNextTokenType() (token.TokenType, error) <span class="cov8" title="1">{

        nextTokenType, err := t.provider.GetNextTokenType()
        if err != nil </span><span class="cov8" title="1">{
                return token.TOKEN_DUMMY, err
        }</span>

        <span class="cov8" title="1">if token.IsSymbolToken(nextTokenType) </span><span class="cov8" title="1">{ // note symbol token will be parse in the corresponding primitive value state
                err = t.astConstructor.RecordSyntaxSymbol(nextTokenType)
                if err != nil </span><span class="cov0" title="0">{
                        return token.TOKEN_DUMMY, err
                }</span>
        }

        <span class="cov8" title="1">return nextTokenType, nil</span>
}

func (t *ASTGolangBaseBuilder) ReadBool() (bool, error) <span class="cov8" title="1">{
        return t.provider.ReadBool()
}</span>
func (t *ASTGolangBaseBuilder) ReadNull() error <span class="cov8" title="1">{
        return t.provider.ReadNull()
}</span>

func (t *ASTGolangBaseBuilder) ReadNumber() (float64, error) <span class="cov8" title="1">{
        return t.provider.ReadNumber()
}</span>

func (t *ASTGolangBaseBuilder) ReadString() ([]byte, error) <span class="cov8" title="1">{
        return t.provider.ReadString()
}</span>

func (t *ASTGolangBaseBuilder) ReadVariable() ([]byte, error) <span class="cov0" title="0">{
        return t.provider.ReadVariable()
}</span>

func (t *ASTGolangBaseBuilder) RecordStateValue(valueType ast.AST_NODETYPE, nodeValue interface{}) error <span class="cov8" title="1">{
        return t.astConstructor.RecordStateValue(valueType, nodeValue)
}</span>

func (i *ASTGolangBaseBuilder) GetAST() ast.JsonNode <span class="cov8" title="1">{
        return i.astConstructor.GetAST()
}</span>

func (i *ASTGolangBaseBuilder) HasComplete() bool <span class="cov8" title="1">{
        return i.astConstructor.HasComplete()
}</span>

func (i *ASTGolangBaseBuilder) TopElementType() (ast.AST_NODETYPE, error) <span class="cov8" title="1">{
        return i.astConstructor.TopElementType()
}</span>

func (i *ASTGolangBaseBuilder) HasOpenElements() bool <span class="cov8" title="1">{
        return i.astConstructor.HasOpenElements()
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package golang

import (
        "encoding/json"
        "reflect"
        "strings"

        "github.com/jaksonlin/go-jsonextend/ast"
        "github.com/jaksonlin/go-jsonextend/constructor"
        "github.com/jaksonlin/go-jsonextend/interpreter"
        "github.com/jaksonlin/go-jsonextend/token"
        "github.com/jaksonlin/go-jsonextend/util"
)

type workingItem struct {
        reflectValue reflect.Value
        tokenType    token.TokenType
}

type tokenProvider struct {
        rootOut      reflect.Value
        workingStack *util.Stack[*workingItem]
        visited      map[uintptr]bool // check visited when pop
}

func newTokenProvider(out interface{}) (*tokenProvider, error) <span class="cov8" title="1">{
        s := util.NewStack[*workingItem]()
        v := reflect.ValueOf(out)

        theTokenType := token.GetTokenTypeByReflection(&amp;v)
        if theTokenType == token.TOKEN_UNKNOWN </span><span class="cov0" title="0">{
                return nil, ErrorUnknownData
        }</span>

        <span class="cov8" title="1">s.Push(&amp;workingItem{reflectValue: v, tokenType: theTokenType})

        return &amp;tokenProvider{
                rootOut:      v,
                workingStack: s,
                visited:      make(map[uintptr]bool),
        }, nil</span>
}

var _ constructor.TokenProvider = &amp;tokenProvider{}

func (t *tokenProvider) processArrayItem(item *workingItem) error <span class="cov0" title="0">{
        len := item.reflectValue.Len()
        // push the end tag
        t.workingStack.Push(&amp;workingItem{tokenType: token.TOKEN_RIGHT_BRACKET})
        for i := len - 1; i &gt;= 0; i -= 1 </span><span class="cov0" title="0">{
                element := item.reflectValue.Index(i)
                theTokenType := token.GetTokenTypeByReflection(&amp;element)
                if theTokenType == token.TOKEN_UNKNOWN </span><span class="cov0" title="0">{
                        return ErrorInvalidTypeOnExportedField
                }</span>
                <span class="cov0" title="0">t.workingStack.Push(&amp;workingItem{reflectValue: element, tokenType: theTokenType})</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// for json tag `string`, convert to json for primitive data type
func (t *tokenProvider) parseJsonStringConfig(tokenType token.TokenType, value reflect.Value) error <span class="cov0" title="0">{
        if tokenType == token.TOKEN_BOOLEAN || tokenType == token.TOKEN_NUMBER || tokenType == token.TOKEN_STRING </span><span class="cov0" title="0">{
                astNode, err := ast.NodeFactory(ast.ConvertTokenTypeToNodeType(tokenType), value.Interface())
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">payload, err := interpreter.InterpretAST(astNode, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">t.workingStack.Push(&amp;workingItem{reflectValue: reflect.ValueOf(payload), tokenType: token.TOKEN_STRING})
                return nil</span>
        } else<span class="cov0" title="0"> {
                return ErrorStringConfigTypeInvalid
        }</span>
}

func (t *tokenProvider) parseJsonFieldInfo(jsonTagFieldName string, defaultFieldName string) error <span class="cov8" title="1">{
        fieldName := strings.TrimSpace(jsonTagFieldName)
        if len(fieldName) == 0 </span><span class="cov0" title="0">{
                t.workingStack.Push(&amp;workingItem{reflectValue: reflect.ValueOf(defaultFieldName), tokenType: token.TOKEN_STRING})
        }</span> else<span class="cov8" title="1"> {
                t.workingStack.Push(&amp;workingItem{reflectValue: reflect.ValueOf(fieldName), tokenType: token.TOKEN_STRING})
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (t *tokenProvider) parseJsonTag(defaultFieldName, jsonTag string, valueTokenType token.TokenType, value reflect.Value) error <span class="cov8" title="1">{
        if jsonTag == "-" </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">jsonTagConfig := strings.SplitN(jsonTag, ",", 2)
        if len(jsonTagConfig) == 0 </span><span class="cov0" title="0">{
                return ErrorInvalidJsonTag
        }</span>
        <span class="cov8" title="1">if len(jsonTagConfig) == 1 </span><span class="cov8" title="1">{
                t.workingStack.Push(&amp;workingItem{reflectValue: value, tokenType: valueTokenType})
        }</span> else<span class="cov0" title="0"> {
                fieldOption := strings.TrimSpace(jsonTagConfig[1])
                if fieldOption == "omitempty" &amp;&amp; value.IsZero() </span><span class="cov0" title="0">{
                        return nil
                }</span>
                // set the value first
                <span class="cov0" title="0">if fieldOption == "string" </span><span class="cov0" title="0">{
                        err := t.parseJsonStringConfig(valueTokenType, value)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                } else<span class="cov0" title="0"> {
                        t.workingStack.Push(&amp;workingItem{reflectValue: value, tokenType: valueTokenType})
                }</span>
        }
        <span class="cov8" title="1">return t.parseJsonFieldInfo(jsonTagConfig[0], defaultFieldName)</span>
}

func (t *tokenProvider) processStructField(field reflect.StructField, element reflect.Value) error <span class="cov8" title="1">{
        valueTokenType := token.GetTokenTypeByReflection(&amp;element)
        if valueTokenType == token.TOKEN_UNKNOWN </span><span class="cov0" title="0">{
                return ErrorInvalidTypeOnExportedField
        }</span>

        <span class="cov8" title="1">jsonTag, ok := field.Tag.Lookup("json")
        if !ok </span><span class="cov8" title="1">{
                // in stack value first then key
                t.workingStack.Push(&amp;workingItem{reflectValue: element, tokenType: valueTokenType})
                t.workingStack.Push(&amp;workingItem{reflectValue: reflect.ValueOf(field.Name), tokenType: token.TOKEN_STRING})
        }</span> else<span class="cov8" title="1"> {
                err := t.parseJsonTag(field.Name, jsonTag, valueTokenType, element)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (t *tokenProvider) flattenStruct(workItem *workingItem) error <span class="cov8" title="1">{
        s := util.NewStack[reflect.Value]()
        s.Push(workItem.reflectValue)
        for </span><span class="cov8" title="1">{
                item, err := s.Pop()
                if err != nil </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">for i := item.NumField() - 1; i &gt;= 0; i -= 1 </span><span class="cov8" title="1">{
                        field := item.Type().Field(i)
                        if field.Anonymous </span><span class="cov8" title="1">{
                                s.Push(item.Field(i))
                                continue</span>
                        }
                        <span class="cov8" title="1">if field.IsExported() </span><span class="cov8" title="1">{
                                element := item.Field(i)
                                err = t.processStructField(field, element)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">return nil</span>
}

func (t *tokenProvider) processMapItem(item *workingItem) error <span class="cov0" title="0">{
        for _, key := range item.reflectValue.MapKeys() </span><span class="cov0" title="0">{
                mapValue := item.reflectValue.MapIndex(key)
                valueTokenType := token.GetTokenTypeByReflection(&amp;mapValue)
                if valueTokenType == token.TOKEN_UNKNOWN </span><span class="cov0" title="0">{
                        return ErrorInvalidTypeOnExportedField
                }</span>
                <span class="cov0" title="0">t.workingStack.Push(&amp;workingItem{reflectValue: mapValue, tokenType: valueTokenType})
                keyTokenType := token.GetTokenTypeByReflection(&amp;key)
                if keyTokenType == token.TOKEN_NUMBER </span><span class="cov0" title="0">{
                        keyValue, err := convertNumericToString(key)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">t.workingStack.Push(&amp;workingItem{reflectValue: reflect.ValueOf(keyValue), tokenType: token.TOKEN_STRING})</span>
                } else<span class="cov0" title="0"> if keyTokenType == token.TOKEN_STRING </span><span class="cov0" title="0">{
                        t.workingStack.Push(&amp;workingItem{reflectValue: key, tokenType: token.TOKEN_STRING})
                }</span> else<span class="cov0" title="0"> {
                        return ErrorInvalidMapKey
                }</span>

        }
        <span class="cov0" title="0">return nil</span>
}

func (t *tokenProvider) processObjectItem(item *workingItem) error <span class="cov8" title="1">{
        // push the end tag
        t.workingStack.Push(&amp;workingItem{tokenType: token.TOKEN_RIGHT_BRACE})

        if item.reflectValue.Kind() == reflect.Struct </span><span class="cov8" title="1">{
                if err := t.flattenStruct(item); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov0" title="0"> {
                if err := t.processMapItem(item); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>

}

func (t *tokenProvider) detectCyclicAccess(item *workingItem) error <span class="cov8" title="1">{
        if item.reflectValue.CanAddr() </span><span class="cov8" title="1">{
                addr := getMemoryAddress(item.reflectValue)
                if _, ok := t.visited[addr]; ok </span><span class="cov8" title="1">{
                        return ErrorCyclicAccess
                }</span> else<span class="cov8" title="1"> {
                        t.visited[addr] = true
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (t *tokenProvider) GetNextTokenType() (token.TokenType, error) <span class="cov8" title="1">{

        item, err := t.workingStack.Peek()
        if err != nil </span><span class="cov0" title="0">{
                return token.TOKEN_DUMMY, err
        }</span>
        <span class="cov8" title="1">if item.tokenType == token.TOKEN_NULL </span><span class="cov8" title="1">{
                return token.TOKEN_NULL, nil
        }</span>

        <span class="cov8" title="1">for item.reflectValue.Kind() == reflect.Pointer </span><span class="cov8" title="1">{
                item.reflectValue = item.reflectValue.Elem()
        }</span>

        <span class="cov8" title="1">switch item.tokenType </span>{
        case token.TOKEN_LEFT_BRACKET:<span class="cov0" title="0">
                if err := t.detectCyclicAccess(item); err != nil </span><span class="cov0" title="0">{
                        return token.TOKEN_DUMMY, err
                }</span>
                <span class="cov0" title="0">t.workingStack.Pop()
                t.processArrayItem(item)
                return item.tokenType, nil</span>
        case token.TOKEN_LEFT_BRACE:<span class="cov8" title="1">
                if err := t.detectCyclicAccess(item); err != nil </span><span class="cov8" title="1">{
                        return token.TOKEN_DUMMY, err
                }</span>
                <span class="cov8" title="1">t.workingStack.Pop()
                err := t.processObjectItem(item)
                if err != nil </span><span class="cov0" title="0">{
                        return token.TOKEN_DUMMY, err
                }</span>
                <span class="cov8" title="1">return item.tokenType, nil</span>
        case token.TOKEN_RIGHT_BRACE:<span class="cov8" title="1">
                fallthrough</span>
        case token.TOKEN_RIGHT_BRACKET:<span class="cov8" title="1">
                t.workingStack.Pop()
                return item.tokenType, nil</span>
        default:<span class="cov8" title="1">
                // for primitives, they will be pop when ReadXXX is requested, and we have already marked them visit
                return item.tokenType, nil</span>
        }

}

func (t *tokenProvider) ReadNull() error <span class="cov8" title="1">{
        _, err := t.workingStack.Pop()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}
func (t *tokenProvider) ReadBool() (bool, error) <span class="cov8" title="1">{
        item, err := t.workingStack.Pop()
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">val := item.reflectValue.Bool()
        return val, nil</span>
}

func (t *tokenProvider) ReadString() ([]byte, error) <span class="cov8" title="1">{
        item, err := t.workingStack.Pop()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">val := item.reflectValue.String()
        // use go standard
        v, err := json.Marshal(val)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return v, nil</span>
}

func (t *tokenProvider) ReadNumber() (float64, error) <span class="cov8" title="1">{
        item, err := t.workingStack.Pop()
        if err != nil </span><span class="cov0" title="0">{
                return 0.0, err
        }</span>
        <span class="cov8" title="1">val, err := convertNumberBaseOnKind(item.reflectValue)
        if err != nil </span><span class="cov0" title="0">{
                return 0.0, err
        }</span>
        <span class="cov8" title="1">return val, nil</span>
}

func (t *tokenProvider) ReadVariable() ([]byte, error) <span class="cov0" title="0">{
        // no golang datatype corresponding to variable now, maybe we can extend this later through tag or plugin
        return nil, nil
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package golang

import (
        "html"
        "reflect"
        "strconv"
        "unicode/utf8"
)

// string to number receiver
func convertStringToNumericReceiver(receiver reflect.Value, value string) (reflect.Value, error) <span class="cov0" title="0">{
        // reflect.Value is struct not pointer return a new one
        switch receiver.Kind() </span>{
        case reflect.Int, reflect.Int16, reflect.Int32, reflect.Int64, reflect.Int8:<span class="cov0" title="0">
                val, err := strconv.ParseInt(value, 10, 64)
                return reflect.ValueOf(val).Convert(receiver.Type()), err</span>
        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:<span class="cov0" title="0">
                val, err := strconv.ParseUint(value, 10, 64)
                return reflect.ValueOf(val).Convert(receiver.Type()), err</span>
        default:<span class="cov0" title="0">
                return reflect.Value{}, ErrorUnsupportedDataKind</span>
        }
}

// number reflect.value to string reflect.value
func convertNumericToString(value reflect.Value) (string, error) <span class="cov0" title="0">{
        switch value.Kind() </span>{
        case reflect.Int, reflect.Int16, reflect.Int32, reflect.Int64, reflect.Int8:<span class="cov0" title="0">
                return strconv.FormatInt(value.Int(), 10), nil</span>

        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:<span class="cov0" title="0">
                return strconv.FormatUint(value.Uint(), 10), nil</span>
        case reflect.Float32:<span class="cov0" title="0">
                return strconv.FormatFloat(value.Float(), 'f', -1, 32), nil</span>
        case reflect.Float64:<span class="cov0" title="0">
                return strconv.FormatFloat(value.Float(), 'f', -1, 64), nil</span>
        default:<span class="cov0" title="0">
                return "", ErrorUnsupportedDataKind</span>
        }
}

func getMemoryAddress(v reflect.Value) uintptr <span class="cov8" title="1">{
        switch v.Kind() </span>{
        case reflect.Ptr, reflect.Slice, reflect.Map, reflect.Chan, reflect.Func, reflect.UnsafePointer:<span class="cov0" title="0">
                return v.Pointer()</span>
        case reflect.Interface:<span class="cov0" title="0">
                elem := v.Elem()
                return elem.UnsafeAddr()</span>
        default:<span class="cov8" title="1">
                return v.UnsafeAddr()</span>
        }
}

// repair string as json standard request
func repairUTF8(s string) string <span class="cov0" title="0">{
        if utf8.ValidString(s) </span><span class="cov0" title="0">{
                return s // Already valid UTF-8.
        }</span>

        <span class="cov0" title="0">var repaired []rune
        for len(s) &gt; 0 </span><span class="cov0" title="0">{
                r, size := utf8.DecodeRuneInString(s)
                repaired = append(repaired, r)
                s = s[size:]
        }</span>

        <span class="cov0" title="0">return string(repaired)</span>
}

func htmlEscape(s string) string <span class="cov0" title="0">{
        return html.EscapeString(s)
}</span>

// json input value is always float64, convert to different numeric value based on out element kind
func convertNumberBaseOnKind(val reflect.Value) (float64, error) <span class="cov8" title="1">{

        switch val.Kind() </span>{
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov8" title="1">
                return float64(val.Int()), nil</span>
        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:<span class="cov0" title="0">
                return float64(val.Uint()), nil</span>
        case reflect.Float32, reflect.Float64:<span class="cov0" title="0">
                return val.Float(), nil</span>
        default:<span class="cov0" title="0">
                return 0.0, ErrNotNumericValueField</span>
        }
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package interpreter

import (
        "errors"
        "fmt"
)

const (
        fieldNotFoundConst = "field %s is not found"

        fieldNotFoundOrCannotSetConst      = "field %s is not found or cannot set"
        ExpectingStructInPointerFindOthers = "expecting struct inside pointer but find %s"
        ExpectingArrayInPointerFindOthers  = "expecting array inside pointer but find %s"
        FieldTypeNotMatchAST               = "field type %s is not of ast collection node type"
        FieldNotFound                      = "field with tag %s not found"
)

var (
        ErrorInterpreSymbolFailure           = errors.New("have symbol not consumed")
        ErrorInterpretVariable               = errors.New("error when interpret variable values")
        ErrorInternalInterpreterOutdated     = errors.New("interpreter not update as the ast grows")
        ErrorKeyStringVariableNotResolve     = errors.New("find string variable as object key, but the variable value is missing")
        ErrorVariableValueNotJsonValueType   = errors.New("variable value should be json value type")
        ErrorVariableValueNotFound           = errors.New("variable value is not found")
        ErrorInternalGetPrimitiveValue       = errors.New("try to get primitive value from none-primitive type")
        ErrorInternalShouldBeArrayOrSlice    = errors.New("should be array or slice")
        ErrorInternalMapKeyTypeNotMatchValue = fmt.Errorf("expect bool as key but value is not bool")

        ErrorInternalExpectingPrimitive     = errors.New("expecting primitive values but find others")
        ErrorInternalPtrToArrayFindNotArray = errors.New("expecting pointer to array, but underlying object not array")
        ErrSliceOrArrayNotInit              = errors.New("slice/array not init")
        ErrorUnmarshalStackNoKV             = errors.New("there should not be kv pair in stack")
        ErrorNotSupportedASTNode            = errors.New("not supported ast node")
        ErrorInternalSymbolStackIncorrect   = errors.New("interpret symbol stack invalid")
)

var (
        ErrorUnmarshalNotSlice = errors.New("unmarshal to a non-slice variable")
)

var (
        ErrorReflectNotObject     = errors.New("out element is not map nor struct")
        ErrorReflectInvalidMapKey = errors.New("map key type should be string")
        ErrOutNotNilPointer       = errors.New("out is nil pointer")
)

func NewErrorFiledNotFound(fieldName string) error <span class="cov0" title="0">{
        return fmt.Errorf(fieldNotFoundConst, fieldName)
}</span>

func NewErrFieldCannotSetOrNotfound(fieldName string) error <span class="cov0" title="0">{
        return fmt.Errorf(fieldNotFoundOrCannotSetConst, fieldName)
}</span>

func NewErrorInternalExpectingStructInsidePointerButFindOthers(kind string) error <span class="cov0" title="0">{
        return fmt.Errorf(ExpectingStructInPointerFindOthers, kind)
}</span>
func NewErrorInternalExpectingArrayInsidePointerButFindOthers(kind string) error <span class="cov0" title="0">{
        return fmt.Errorf(ExpectingArrayInPointerFindOthers, kind)
}</span>

func NewErrorInternalFieldTypeNotMatchAST(kind string) error <span class="cov0" title="0">{
        return fmt.Errorf(FieldTypeNotMatchAST, kind)
}</span>

func NewErrorFieldNotFound(field string) error <span class="cov0" title="0">{
        return fmt.Errorf(FieldNotFound, field)
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package interpreter

import (
        "bytes"
        "encoding/json"
        "strconv"
        "strings"

        "github.com/jaksonlin/go-jsonextend/ast"
        "github.com/jaksonlin/go-jsonextend/util"
)

type JsonVisitor interface {
        VisitStringNode(node *ast.JsonStringNode) error
        VisitNumberNode(node *ast.JsonNumberNode) error
        VisitBooleanNode(node *ast.JsonBooleanNode) error
        VisitNullNode(node *ast.JsonNullNode) error
        VisitArrayNode(node *ast.JsonArrayNode) error
        VisitKeyValuePairNode(node *ast.JsonKeyValuePairNode) error
        VisitObjectNode(node *ast.JsonObjectNode) error
        VisitVariableNode(node *ast.JsonExtendedVariableNode) error
        VisitStringWithVariableNode(node *ast.JsonExtendedStringWIthVariableNode) error
}

type prettyPrintVisitor struct {
        sb           *bytes.Buffer
        indentString string
        indent       int
        variables    map[string]interface{}
        stackNode    *util.Stack[ast.JsonNode]
        stackFormat  *util.Stack[byte]
}

var _ JsonVisitor = &amp;prettyPrintVisitor{}

var colonFormat = []byte{' ', ':', ' '}

func NewPPInterpreter(variables map[string]interface{}) *prettyPrintVisitor <span class="cov8" title="1">{

        return &amp;prettyPrintVisitor{
                sb:           bytes.NewBuffer(make([]byte, 0)),
                indentString: strings.Repeat(" ", 4),
                indent:       0,
                variables:    variables,
                stackNode:    util.NewStack[ast.JsonNode](),
                stackFormat:  util.NewStack[byte](),
        }
}</span>

func (s *prettyPrintVisitor) getSymbolLength() int <span class="cov8" title="1">{
        return s.stackFormat.Length()
}</span>

func (s *prettyPrintVisitor) WriteSymbol() error <span class="cov8" title="1">{
        symbol, e := s.stackFormat.Pop()
        if e != nil </span><span class="cov0" title="0">{
                return e
        }</span>
        // the caller is the last element in an object/array
        <span class="cov8" title="1">if symbol == ']' || symbol == '}' </span><span class="cov8" title="1">{
                //write return line
                s.sb.WriteByte('\n')
                // reduce indent
                s.indent--
                s.sb.WriteString(strings.Repeat(s.indentString, s.indent))
                // put the closing symbol
                s.sb.WriteByte(symbol)
                // if we are in the middle of any collection,  break after writing the `comma`
                // else we will consume any number of closing symbols in between!
                for symbol != ',' </span><span class="cov8" title="1">{
                        symbol, e = s.stackFormat.Pop()
                        if e != nil </span><span class="cov8" title="1">{
                                return e
                        }</span>
                        <span class="cov8" title="1">if symbol != ',' </span><span class="cov8" title="1">{
                                s.indent--
                                s.sb.WriteByte('\n')
                                s.sb.WriteString(strings.Repeat(s.indentString, s.indent))
                        }</span>
                        <span class="cov8" title="1">s.sb.WriteByte(symbol)</span>
                }
                <span class="cov8" title="1">s.sb.WriteByte('\n')
                s.sb.WriteString(strings.Repeat(s.indentString, s.indent))</span>

        } else<span class="cov8" title="1"> {

                if symbol == ':' </span><span class="cov8" title="1">{
                        s.sb.Write(colonFormat)
                }</span> else<span class="cov8" title="1"> {
                        s.sb.WriteByte(symbol)
                        s.sb.WriteByte('\n')
                        s.sb.WriteString(strings.Repeat(s.indentString, s.indent))
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (s *prettyPrintVisitor) VisitStringNode(node *ast.JsonStringNode) error <span class="cov8" title="1">{
        s.sb.Write(node.Value)
        return s.WriteSymbol()
}</span>

func (s *prettyPrintVisitor) VisitNumberNode(node *ast.JsonNumberNode) error <span class="cov8" title="1">{
        s.sb.WriteString(strconv.FormatFloat(node.Value, 'f', -1, 64))
        return s.WriteSymbol()
}</span>

func (s *prettyPrintVisitor) VisitBooleanNode(node *ast.JsonBooleanNode) error <span class="cov8" title="1">{
        s.sb.WriteString(strconv.FormatBool(node.Value))
        return s.WriteSymbol()
}</span>

func (s *prettyPrintVisitor) VisitNullNode(node *ast.JsonNullNode) error <span class="cov8" title="1">{
        s.sb.WriteString("null")
        return s.WriteSymbol()
}</span>

func (s *prettyPrintVisitor) VisitStringWithVariableNode(node *ast.JsonExtendedStringWIthVariableNode) error <span class="cov8" title="1">{
        var result []byte = make([]byte, len(node.Value))
        copy(result, node.Value)
        for varName, varDollarName := range node.Variables </span><span class="cov8" title="1">{
                varVal, ok := s.variables[varName]
                if ok </span><span class="cov8" title="1">{
                        content, err := json.Marshal(varVal)
                        if err != nil </span><span class="cov0" title="0">{
                                return ErrorInterpretVariable
                        }</span>
                        // remove the json string's leading and trailing double quotation mark, otherwise you will get something ""value"", which is invalid string
                        <span class="cov8" title="1">if content[0] == '"' </span><span class="cov8" title="1">{
                                content = content[1 : len(content)-1]
                        }</span>
                        <span class="cov8" title="1">result = bytes.ReplaceAll(result, varDollarName, content)</span>
                }
        }
        // the varaible value is of string type, remove the leading and trailing double quotation mark

        <span class="cov8" title="1">s.sb.Write(result)
        return s.WriteSymbol()</span>
}

func (s *prettyPrintVisitor) VisitVariableNode(node *ast.JsonExtendedVariableNode) error <span class="cov8" title="1">{

        varVal, ok := s.variables[node.Variable] // allow partial rendered
        if !ok </span><span class="cov0" title="0">{
                s.sb.Write(node.Value)
                return s.WriteSymbol()
        }</span> else<span class="cov8" title="1"> {
                content, err := json.Marshal(varVal)
                if err != nil </span><span class="cov0" title="0">{
                        return ErrorInterpretVariable
                }</span>
                <span class="cov8" title="1">if content[0] == '"' </span><span class="cov0" title="0">{
                        content = content[1 : len(content)-1]
                }</span>
                <span class="cov8" title="1">s.sb.Write(content)</span>
        }

        <span class="cov8" title="1">return s.WriteSymbol()</span>
}

func (s *prettyPrintVisitor) VisitArrayNode(node *ast.JsonArrayNode) error <span class="cov8" title="1">{
        s.sb.WriteString("[\n")
        s.indent++
        s.sb.WriteString(strings.Repeat(s.indentString, s.indent))
        for i := len(node.Value) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                s.stackNode.Push(node.Value[i])
                if i == len(node.Value)-1 </span><span class="cov8" title="1">{
                        s.stackFormat.Push(']')
                }</span> else<span class="cov8" title="1"> {
                        s.stackFormat.Push(',')
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (s *prettyPrintVisitor) VisitKeyValuePairNode(node *ast.JsonKeyValuePairNode) error <span class="cov8" title="1">{
        // stack, first in last out, value go first ;-)
        s.stackNode.Push(node.Value)
        s.stackNode.Push(node.Key)

        return nil
}</span>

func (s *prettyPrintVisitor) GetOutput() []byte <span class="cov8" title="1">{
        return s.sb.Bytes()
}</span>

func (s *prettyPrintVisitor) VisitObjectNode(node *ast.JsonObjectNode) error <span class="cov8" title="1">{
        s.sb.WriteString("{\n")
        s.indent++
        s.sb.WriteString(strings.Repeat(s.indentString, s.indent))
        for i := len(node.Value) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                s.stackNode.Push(node.Value[i])
                if i == len(node.Value)-1 </span><span class="cov8" title="1">{ // stack, first in last out
                        s.stackFormat.Push('}')
                        s.stackFormat.Push(':')
                }</span> else<span class="cov8" title="1"> {
                        s.stackFormat.Push(',')
                        s.stackFormat.Push(':')
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func PrettyInterpret(node ast.JsonNode, variables map[string]interface{}) ([]byte, error) <span class="cov8" title="1">{
        // deep first traverse the AST

        visitor := NewPPInterpreter(variables)
        visitor.stackNode.Push(node)

        for </span><span class="cov8" title="1">{
                node, err := visitor.stackNode.Pop()
                if err != nil </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov8" title="1">err = node.Visit(visitor)
                if err != nil </span><span class="cov8" title="1">{
                        if err != util.ErrorEndOfStack </span><span class="cov0" title="0">{
                                return nil, err
                        }</span> else<span class="cov8" title="1"> {
                                break</span>
                        }
                }

        }

        <span class="cov8" title="1">if visitor.getSymbolLength() &gt; 0 </span><span class="cov0" title="0">{
                return nil, ErrorInterpreSymbolFailure
        }</span>
        <span class="cov8" title="1">rs := visitor.GetOutput()
        return rs, nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package interpreter

import (
        "bytes"
        "encoding/json"
        "strconv"

        "github.com/jaksonlin/go-jsonextend/ast"
        "github.com/jaksonlin/go-jsonextend/token"
        "github.com/jaksonlin/go-jsonextend/util"
)

type standardVisitor struct {
        sb          *bytes.Buffer
        variables   map[string]interface{}
        stackNode   *util.Stack[ast.JsonNode]
        stackFormat *util.Stack[byte]
}

var _ JsonVisitor = &amp;standardVisitor{}

func NewInterpreter(variables map[string]interface{}) *standardVisitor <span class="cov8" title="1">{

        return &amp;standardVisitor{
                sb:          bytes.NewBuffer(make([]byte, 0)),
                variables:   variables,
                stackNode:   util.NewStack[ast.JsonNode](),
                stackFormat: util.NewStack[byte](),
        }
}</span>

func (s *standardVisitor) getSymbolLength() int <span class="cov8" title="1">{
        return s.stackFormat.Length()
}</span>

func (s *standardVisitor) WriteSymbol() error <span class="cov8" title="1">{
        symbol, e := s.stackFormat.Pop()
        if e != nil </span><span class="cov0" title="0">{
                return e
        }</span>
        <span class="cov8" title="1">s.sb.WriteByte(symbol)
        // the caller is the last element in an object/array
        if symbol == ']' || symbol == '}' </span><span class="cov8" title="1">{
                // if we are in the middle of any collection, write one more `comma` after the closing symbol
                // stack top [`]` , `}`, ... `,` , `]`], the first `]` has been poped above, we need to write one more `,`
                for symbol != ',' </span><span class="cov8" title="1">{
                        symbol, e = s.stackFormat.Pop()
                        if e != nil </span><span class="cov8" title="1">{
                                return e
                        }</span>
                        <span class="cov8" title="1">s.sb.WriteByte(symbol)</span>
                }

        }
        <span class="cov8" title="1">return nil</span>
}

func (s *standardVisitor) VisitStringNode(node *ast.JsonStringNode) error <span class="cov8" title="1">{
        s.sb.Write(node.Value)
        return s.WriteSymbol()
}</span>

func (s *standardVisitor) VisitNumberNode(node *ast.JsonNumberNode) error <span class="cov8" title="1">{
        s.sb.WriteString(strconv.FormatFloat(node.Value, 'f', -1, 64))
        return s.WriteSymbol()
}</span>

func (s *standardVisitor) VisitBooleanNode(node *ast.JsonBooleanNode) error <span class="cov8" title="1">{
        if node.Value </span><span class="cov8" title="1">{
                s.sb.Write(token.TrueBytes)
        }</span> else<span class="cov0" title="0"> {
                s.sb.Write(token.FalseBytes)
        }</span>
        <span class="cov8" title="1">return s.WriteSymbol()</span>
}

func (s *standardVisitor) VisitNullNode(node *ast.JsonNullNode) error <span class="cov8" title="1">{
        s.sb.Write(token.NullBytes)
        return s.WriteSymbol()
}</span>

func (s *standardVisitor) VisitStringWithVariableNode(node *ast.JsonExtendedStringWIthVariableNode) error <span class="cov8" title="1">{
        var result []byte = make([]byte, len(node.Value))
        copy(result, node.Value)
        for varName, varDollarName := range node.Variables </span><span class="cov8" title="1">{
                varVal, ok := s.variables[varName]
                if ok </span><span class="cov8" title="1">{
                        content, err := json.Marshal(varVal)
                        if err != nil </span><span class="cov0" title="0">{
                                return ErrorInterpretVariable
                        }</span>
                        // remove the json string's leading and trailing double quotation mark, otherwise you will get something ""value"", which is invalid string
                        <span class="cov8" title="1">if content[0] == '"' </span><span class="cov8" title="1">{
                                content = content[1 : len(content)-1]
                        }</span>
                        <span class="cov8" title="1">result = bytes.ReplaceAll(result, varDollarName, content)</span>
                }
        }
        // the varaible value is of string type, remove the leading and trailing double quotation mark

        <span class="cov8" title="1">s.sb.Write(result)
        return s.WriteSymbol()</span>
}

func (s *standardVisitor) VisitVariableNode(node *ast.JsonExtendedVariableNode) error <span class="cov8" title="1">{

        varVal, ok := s.variables[node.Variable] // allow partial rendered
        if !ok </span><span class="cov0" title="0">{
                s.sb.Write(node.Value)
                return s.WriteSymbol()
        }</span> else<span class="cov8" title="1"> {
                content, err := json.Marshal(varVal)
                if err != nil </span><span class="cov0" title="0">{
                        return ErrorInterpretVariable
                }</span>
                <span class="cov8" title="1">if content[0] == '"' </span><span class="cov0" title="0">{
                        content = content[1 : len(content)-1]
                }</span>
                <span class="cov8" title="1">s.sb.Write(content)</span>
        }

        <span class="cov8" title="1">return s.WriteSymbol()</span>
}

func (s *standardVisitor) VisitArrayNode(node *ast.JsonArrayNode) error <span class="cov8" title="1">{
        s.sb.WriteByte('[')

        for i := len(node.Value) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                s.stackNode.Push(node.Value[i])
                if i == len(node.Value)-1 </span><span class="cov8" title="1">{
                        s.stackFormat.Push(']')
                }</span> else<span class="cov8" title="1"> {
                        s.stackFormat.Push(',')
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (s *standardVisitor) VisitKeyValuePairNode(node *ast.JsonKeyValuePairNode) error <span class="cov8" title="1">{
        // stack, first in last out, value go first ;-)
        s.stackNode.Push(node.Value)
        s.stackNode.Push(node.Key)

        return nil
}</span>

func (s *standardVisitor) GetOutput() []byte <span class="cov8" title="1">{
        return s.sb.Bytes()
}</span>

func (s *standardVisitor) VisitObjectNode(node *ast.JsonObjectNode) error <span class="cov8" title="1">{
        s.sb.WriteByte('{')
        for i := len(node.Value) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                s.stackNode.Push(node.Value[i])
                if i == len(node.Value)-1 </span><span class="cov8" title="1">{ // stack, first in last out
                        s.stackFormat.Push('}')
                        s.stackFormat.Push(':')
                }</span> else<span class="cov8" title="1"> {
                        s.stackFormat.Push(',')
                        s.stackFormat.Push(':')
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func InterpretAST(node ast.JsonNode, variables map[string]interface{}) ([]byte, error) <span class="cov8" title="1">{
        // deep first traverse the AST

        visitor := NewInterpreter(variables)
        visitor.stackNode.Push(node)

        for </span><span class="cov8" title="1">{
                node, err := visitor.stackNode.Pop()
                if err != nil </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov8" title="1">err = node.Visit(visitor)
                if err != nil </span><span class="cov8" title="1">{
                        if err != util.ErrorEndOfStack </span><span class="cov0" title="0">{
                                return nil, err
                        }</span> else<span class="cov8" title="1"> {
                                break</span>
                        }
                }

        }

        <span class="cov8" title="1">if visitor.getSymbolLength() &gt; 0 </span><span class="cov0" title="0">{
                return nil, ErrorInterpreSymbolFailure
        }</span>
        <span class="cov8" title="1">rs := visitor.GetOutput()
        return rs, nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package jsonextend

import (
        "errors"
        "io"

        "github.com/jaksonlin/go-jsonextend/interpreter"
        "github.com/jaksonlin/go-jsonextend/tokenizer"
        "github.com/jaksonlin/go-jsonextend/unmarshaler"
)

func Parse(reader io.Reader, variables map[string]interface{}) ([]byte, error) <span class="cov8" title="1">{
        sm := tokenizer.NewTokenizerStateMachineFromIOReader(reader)
        err := sm.ProcessData()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if sm.GetASTBuilder().HasOpenElements() </span><span class="cov0" title="0">{
                return nil, errors.New("invalid json")
        }</span>
        <span class="cov8" title="1">ast := sm.GetAST()
        return interpreter.PrettyInterpret(ast, variables)</span>
}

func Unmarshal(reader io.Reader, variables map[string]interface{}, out interface{}) error <span class="cov8" title="1">{
        sm := tokenizer.NewTokenizerStateMachineFromIOReader(reader)
        err := sm.ProcessData()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if sm.GetASTBuilder().HasOpenElements() </span><span class="cov0" title="0">{
                return errors.New("invalid json")
        }</span>
        <span class="cov8" title="1">ast := sm.GetAST()
        return unmarshaler.UnmarshallAST(ast, variables, out)</span>
}

func Marshal(v interface{}) ([]byte, error) <span class="cov8" title="1">{
        sm, err := tokenizer.NewTokenizerStateMachineFromGoData(v)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">err = sm.ProcessData()
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if sm.GetASTBuilder().HasOpenElements() </span><span class="cov0" title="0">{
                return nil, errors.New("invalid object")
        }</span>
        <span class="cov8" title="1">ast := sm.GetAST()
        return interpreter.InterpretAST(ast, nil)</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package token

import "reflect"

type TokenType uint

const (
        // The token type is a string
        TOKEN_STRING TokenType = iota
        // The token type is a number
        TOKEN_NUMBER
        // The token type is a boolean
        TOKEN_BOOLEAN
        // The token type is a null
        TOKEN_NULL
        // The token type is a left brace
        TOKEN_LEFT_BRACE
        // The token type is a right brace
        TOKEN_RIGHT_BRACE
        // The token type is a left bracket
        TOKEN_LEFT_BRACKET
        // The token type is a right bracket
        TOKEN_RIGHT_BRACKET
        // The token type is a colon
        TOKEN_COLON
        // The token type is a comma
        TOKEN_COMMA
        // customize token type
        TOKEN_VARIABLE
        // variable in string, a string can have multiple variable
        TOKEN_STRING_WITH_VARIABLE
        TOKEN_SPACE
        // deciaml token
        TOKEN_NUMBER_DECIMAL
        //
        TOKEN_DOUBLE_QUOTATION

        TOKEN_UNKNOWN TokenType = 97
        TOKEN_DUMMY   TokenType = 98
        TOKEN_DROP    TokenType = 99
)

// symbol token of json, these are the format token that need to use to construct the AST/ syntax checker
// double quotaion though is also symbol, it is value symbol, not json protocol symbol to hold the format
func IsSymbolToken(t TokenType) bool <span class="cov8" title="1">{
        return t == TOKEN_COMMA || t == TOKEN_COLON || t == TOKEN_LEFT_BRACE || t == TOKEN_LEFT_BRACKET || t == TOKEN_RIGHT_BRACE || t == TOKEN_RIGHT_BRACKET
}</span>

func GetTokenTypeByReflection(v *reflect.Value) TokenType <span class="cov8" title="1">{
        rv := *v
        for rv.Kind() == reflect.Pointer </span><span class="cov8" title="1">{
                if rv.IsNil() </span><span class="cov8" title="1">{
                        return TOKEN_NULL
                }</span>
                <span class="cov8" title="1">rv = rv.Elem()</span>
        }
        <span class="cov8" title="1">switch rv.Kind() </span>{
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,
                reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr,
                reflect.Float32, reflect.Float64:<span class="cov8" title="1">
                return TOKEN_NUMBER</span>
        case reflect.String:<span class="cov8" title="1">
                return TOKEN_STRING</span>
        case reflect.Bool:<span class="cov8" title="1">
                return TOKEN_BOOLEAN</span>
        case reflect.Slice, reflect.Array:<span class="cov0" title="0">
                return TOKEN_LEFT_BRACKET</span>
        case reflect.Struct, reflect.Map:<span class="cov8" title="1">
                return TOKEN_LEFT_BRACE</span>
        default:<span class="cov0" title="0">
                return TOKEN_UNKNOWN</span>
        }
}

var (
        NullBytes  []byte = []byte("null")
        FalseBytes []byte = []byte("false")
        TrueBytes  []byte = []byte("true")
)
</pre>
		
		<pre class="file" id="file16" style="display: none">package tokenizer

import (
        "github.com/jaksonlin/go-jsonextend/constructor"
        "github.com/jaksonlin/go-jsonextend/token"
)

type ArrayState struct {
        TokenReader
}

var _ Tokenizer = &amp;ArrayState{}

func (i *ArrayState) GetMode() StateMode <span class="cov0" title="0">{
        return ARRAY_MODE
}</span>

func (i *ArrayState) ProcessData(provider constructor.TokenProvider) error <span class="cov8" title="1">{

        nextTokenType, err := provider.GetNextTokenType()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return i.switchState(nextTokenType)</span>
}

func (i *ArrayState) switchState(nextTokenType token.TokenType) error <span class="cov8" title="1">{
        //route trigger token
        err := i.stateMachine.SwitchStateByToken(nextTokenType)
        if err != nil </span><span class="cov8" title="1">{
                switch nextTokenType </span>{
                // valid but not trigger
                case token.TOKEN_SPACE:<span class="cov8" title="1"></span>
                case token.TOKEN_COMMA:<span class="cov8" title="1"></span>
                // enclose symbol
                case token.TOKEN_RIGHT_BRACKET:<span class="cov8" title="1">
                        i.stateMachine.SwitchToLatestState()</span>
                default:<span class="cov0" title="0">
                        return NewErrorIncorrectToken(i.GetMode(), nextTokenType)</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package tokenizer

import "github.com/jaksonlin/go-jsonextend/constructor"

type BooleanState struct {
        PrimitiveValueTokenStateBase
}

var _ PrimitiveValueTokenizer = &amp;BooleanState{}

func (i *BooleanState) GetMode() StateMode <span class="cov8" title="1">{
        return BOOLEAN_MODE
}</span>

func (i *BooleanState) ProcessData(provider constructor.TokenProvider) error <span class="cov8" title="1">{
        // in boolean state we will consume until it is the end of boolean.
        value, err := provider.ReadBool()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">err = i.storeTokenValue(i.GetMode(), value)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return i.switchState()</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package tokenizer

import (
        "errors"
        "fmt"

        "github.com/jaksonlin/go-jsonextend/token"
)

const (
        incorrectToken = "unexpected token found in mode: %d, token type: %d"
)

var (
        ErrorIncorrectValueTypeForConstructAST = errors.New("incorrect value type for construct ast")
        ErrorInternalASTProcotolChanged        = errors.New("detect unexpect ast stack change, not kv, array, object, NodeType at top of stack")
        ErrorUnexpectedEOF                     = errors.New("unexpected EOF")
        ErrorTokenRouteNotConfigure            = errors.New("token route not configure")
        ErrorExtendedVariableFormatIncorrect   = errors.New("variable should be of ${variableName} format")
)

func NewErrorIncorrectToken(mode StateMode, token token.TokenType) error <span class="cov0" title="0">{
        return fmt.Errorf(incorrectToken, mode, token)
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package tokenizer

import (
        "io"

        "github.com/jaksonlin/go-jsonextend/constructor"
        "github.com/jaksonlin/go-jsonextend/constructor/bytebase"
        "github.com/jaksonlin/go-jsonextend/constructor/golang"
        "github.com/jaksonlin/go-jsonextend/token"
)

func NewTokenizerStateMachineFromIOReader(reader io.Reader) *TokenizerStateMachine <span class="cov8" title="1">{
        astMan := bytebase.NewASTByteBaseBuilder(reader)
        return newTokenizerStateMachine(astMan)
}</span>

func NewTokenizerStateMachineFromGoData(obj interface{}) (*TokenizerStateMachine, error) <span class="cov8" title="1">{
        astMan, err := golang.NewASTGolangBaseBuilder(obj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return newTokenizerStateMachine(astMan), nil</span>
}

func newTokenizerStateMachine(builder constructor.ASTBuilder) *TokenizerStateMachine <span class="cov8" title="1">{

        sm := TokenizerStateMachine{}
        sm.astBuilder = builder
        sm.initState = &amp;InitState{NewTokenReader(&amp;sm)}
        sm.arrayState = &amp;ArrayState{NewTokenReader(&amp;sm)}
        sm.objectState = &amp;ObjectState{NewTokenReader(&amp;sm)}
        sm.stringState = &amp;StringState{NewPrimitiveValueTokenStateBase(&amp;sm)}
        sm.numberState = &amp;NumberState{NewPrimitiveValueTokenStateBase(&amp;sm)}
        sm.booleanState = &amp;BooleanState{NewPrimitiveValueTokenStateBase(&amp;sm)}
        sm.nullState = &amp;NullState{NewPrimitiveValueTokenStateBase(&amp;sm)}
        sm.variableState = &amp;VariableState{NewPrimitiveValueTokenStateBase(&amp;sm)}
        //construct a route table instead of using switch every where.
        sm.defaultRoute = map[token.TokenType]stateChangeFunc{

                token.TOKEN_STRING: func() error </span><span class="cov8" title="1">{
                        sm.currentState = sm.stringState
                        return nil
                }</span>,
                token.TOKEN_NUMBER: func() error <span class="cov8" title="1">{
                        sm.currentState = sm.numberState
                        return nil
                }</span>,
                token.TOKEN_BOOLEAN: func() error <span class="cov8" title="1">{
                        sm.currentState = sm.booleanState
                        return nil
                }</span>,
                token.TOKEN_NULL: func() error <span class="cov8" title="1">{
                        sm.currentState = sm.nullState
                        return nil
                }</span>,
                token.TOKEN_LEFT_BRACKET: func() error <span class="cov8" title="1">{
                        sm.currentState = sm.arrayState
                        return nil
                }</span>,
                token.TOKEN_LEFT_BRACE: func() error <span class="cov8" title="1">{
                        sm.currentState = sm.objectState
                        return nil
                }</span>,
                token.TOKEN_VARIABLE: func() error <span class="cov8" title="1">{
                        sm.currentState = sm.variableState
                        return nil
                }</span>,
        }
        <span class="cov8" title="1">sm.currentState = sm.initState
        return &amp;sm</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package tokenizer

import (
        "github.com/jaksonlin/go-jsonextend/constructor"
        "github.com/jaksonlin/go-jsonextend/token"
)

type InitState struct {
        TokenReader
}

var _ Tokenizer = &amp;InitState{}

func (i *InitState) GetMode() StateMode <span class="cov0" title="0">{
        return INIT_MODE
}</span>

func (i *InitState) ProcessData(provider constructor.TokenProvider) error <span class="cov8" title="1">{

        nextTokenType, err := provider.GetNextTokenType()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return i.switchState(nextTokenType)</span>
}

func (i *InitState) switchState(nextTokenType token.TokenType) error <span class="cov8" title="1">{
        err := i.stateMachine.SwitchStateByToken(nextTokenType)
        if err != nil </span><span class="cov8" title="1">{
                switch nextTokenType </span>{
                case token.TOKEN_SPACE:<span class="cov8" title="1"></span>
                default:<span class="cov0" title="0">
                        return NewErrorIncorrectToken(i.GetMode(), nextTokenType)</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package tokenizer

import (
        "github.com/jaksonlin/go-jsonextend/constructor"
)

type NullState struct {
        PrimitiveValueTokenStateBase
}

var _ PrimitiveValueTokenizer = &amp;NullState{}

func (i *NullState) GetMode() StateMode <span class="cov8" title="1">{
        return NULL_MODE
}</span>

func (i *NullState) ProcessData(provider constructor.TokenProvider) error <span class="cov8" title="1">{
        err := provider.ReadNull()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">err = i.storeTokenValue(i.GetMode(), nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return i.switchState()</span>

}
</pre>
		
		<pre class="file" id="file22" style="display: none">package tokenizer

import (
        "github.com/jaksonlin/go-jsonextend/constructor"
)

type NumberState struct {
        PrimitiveValueTokenStateBase
}

var _ PrimitiveValueTokenizer = &amp;NumberState{}

func (i *NumberState) GetMode() StateMode <span class="cov8" title="1">{
        return NUMBER_MODE
}</span>

func (i *NumberState) ProcessData(provider constructor.TokenProvider) error <span class="cov8" title="1">{
        f64, err := provider.ReadNumber()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">err = i.storeTokenValue(i.GetMode(), f64)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return i.switchState()</span>

}
</pre>
		
		<pre class="file" id="file23" style="display: none">package tokenizer

import (
        "github.com/jaksonlin/go-jsonextend/constructor"
        "github.com/jaksonlin/go-jsonextend/token"
)

type ObjectState struct {
        TokenReader
}

var _ Tokenizer = &amp;ObjectState{}

func (i *ObjectState) GetMode() StateMode <span class="cov0" title="0">{
        return OBJECT_MODE
}</span>

func (i *ObjectState) ProcessData(provider constructor.TokenProvider) error <span class="cov8" title="1">{

        nextTokenType, err := provider.GetNextTokenType()
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return i.switchState(nextTokenType)</span>
}

func (i *ObjectState) switchState(nextTokenType token.TokenType) error <span class="cov8" title="1">{
        //route trigger token
        err := i.stateMachine.SwitchStateByToken(nextTokenType)
        if err != nil </span><span class="cov8" title="1">{
                switch nextTokenType </span>{
                // valid but not trigger symbol
                case token.TOKEN_SPACE:<span class="cov8" title="1"></span>
                case token.TOKEN_COLON:<span class="cov8" title="1"></span>
                case token.TOKEN_COMMA:<span class="cov8" title="1"></span>
                // enclose symbol
                case token.TOKEN_RIGHT_BRACE:<span class="cov8" title="1">
                        i.stateMachine.SwitchToLatestState()</span>
                default:<span class="cov0" title="0">
                        return NewErrorIncorrectToken(i.GetMode(), nextTokenType)</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package tokenizer

import "github.com/jaksonlin/go-jsonextend/constructor"

type StateMode uint

const (
        INIT_MODE StateMode = iota
        OBJECT_MODE
        ARRAY_MODE
        STRING_MODE
        NUMBER_MODE
        BOOLEAN_MODE
        NULL_MODE
        VARIABLE_MODE
        STRING_VARIABLE_MODE
)

// common tokenizer implementation
type Tokenizer interface {
        ProcessData(provider constructor.TokenProvider) error
        GetMode() StateMode
}

// for primitive value token, they hold primitive value (not array/object)
// store their value to somewhere based on extracted value,
// and the switch of state is based on AST current state, therefore no need for parameterized state change
type PrimitiveStateProcessor interface {
        switchState() error
        storeTokenValue(mode StateMode, value interface{}) error
}

type PrimitiveValueTokenizer interface {
        Tokenizer
        PrimitiveStateProcessor
}

// for the base, only provides what `PrimitiveStateProcessor` needs
type PrimitiveValueTokenStateBase struct {
        stateMachine *TokenizerStateMachine
}

var _ PrimitiveStateProcessor = &amp;PrimitiveValueTokenStateBase{}

func NewPrimitiveValueTokenStateBase(sm *TokenizerStateMachine) PrimitiveValueTokenStateBase <span class="cov8" title="1">{
        return PrimitiveValueTokenStateBase{
                stateMachine: sm,
        }
}</span>

// state machine construct the AST on the fly, use the AST for state change after producing a primivite value
func (i *PrimitiveValueTokenStateBase) switchState() error <span class="cov8" title="1">{

        if err := i.stateMachine.SwitchToLatestState(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// it will also handle the store of the value to update the AST
func (i *PrimitiveValueTokenStateBase) storeTokenValue(mode StateMode, value interface{}) error <span class="cov8" title="1">{
        return i.stateMachine.RecordStateValue(mode, value)
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">package tokenizer

import (
        "github.com/jaksonlin/go-jsonextend/ast"
        "github.com/jaksonlin/go-jsonextend/constructor"
        "github.com/jaksonlin/go-jsonextend/token"

        "io"
)

type stateChangeFunc func() error

type TokenizerStateMachine struct {
        stringState   Tokenizer
        numberState   Tokenizer
        booleanState  Tokenizer
        nullState     Tokenizer
        arrayState    Tokenizer
        objectState   Tokenizer
        initState     Tokenizer
        variableState Tokenizer
        currentState  Tokenizer
        // use a route table to route the default state other than a large switch case
        defaultRoute map[token.TokenType]stateChangeFunc // replace of ToxxxState
        // consturct the AST and check syntax when processing the token in the fly
        astBuilder constructor.ASTBuilder
}

func (i *TokenizerStateMachine) SwitchStateByToken(tokenType token.TokenType) error <span class="cov8" title="1">{
        proxy, ok := i.defaultRoute[tokenType]
        if !ok </span><span class="cov8" title="1">{
                return ErrorTokenRouteNotConfigure
        }</span>
        <span class="cov8" title="1">proxy()
        return nil</span>
}

func (i *TokenizerStateMachine) RecordStateValue(valueType StateMode, nodeValue interface{}) error <span class="cov8" title="1">{
        // keeps a matching between the state mode and the ast node type, may change in the future
        switch valueType </span>{
        case STRING_MODE:<span class="cov8" title="1">
                return i.astBuilder.RecordStateValue(ast.AST_STRING, nodeValue)</span>
        case BOOLEAN_MODE:<span class="cov8" title="1">
                return i.astBuilder.RecordStateValue(ast.AST_BOOLEAN, nodeValue)</span>
        case NUMBER_MODE:<span class="cov8" title="1">
                return i.astBuilder.RecordStateValue(ast.AST_NUMBER, nodeValue)</span>
        case NULL_MODE:<span class="cov8" title="1">
                return i.astBuilder.RecordStateValue(ast.AST_NULL, nodeValue)</span>
        case VARIABLE_MODE:<span class="cov8" title="1">
                return i.astBuilder.RecordStateValue(ast.AST_VARIABLE, nodeValue)</span>
        case STRING_VARIABLE_MODE:<span class="cov8" title="1">
                return i.astBuilder.RecordStateValue(ast.AST_STRING_VARIABLE, nodeValue)</span>
        default:<span class="cov0" title="0">
                return ErrorIncorrectValueTypeForConstructAST</span>
        }
}

// use AST to switch the state of the machine when primitive values end of their processing
func (i *TokenizerStateMachine) SwitchToLatestState() error <span class="cov8" title="1">{
        if i.astBuilder.HasComplete() </span><span class="cov8" title="1">{
                // cannot and no need to route, the ast has parsed an json object
                return nil
        }</span>
        <span class="cov8" title="1">n, err := i.astBuilder.TopElementType()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">switch n </span>{
        case ast.AST_ARRAY:<span class="cov8" title="1">
                i.currentState = i.arrayState
                return nil</span>
        case ast.AST_OBJECT:<span class="cov8" title="1">
                fallthrough</span>
        case ast.AST_KVPAIR:<span class="cov8" title="1">
                i.currentState = i.objectState
                return nil</span>
        default:<span class="cov0" title="0">
                return ErrorInternalASTProcotolChanged</span>
        }
}

func (i *TokenizerStateMachine) ProcessData() error <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                // 1. the ast complete parsing json, end and not read the rest of bytes
                if i.astBuilder.HasComplete() </span><span class="cov8" title="1">{
                        return nil
                }</span>
                <span class="cov8" title="1">err := i.currentState.ProcessData(i.astBuilder)
                // 2. the stream ends, and ast is still expecting content, fail.

                if err != nil </span><span class="cov8" title="1">{
                        if err == io.EOF </span><span class="cov0" title="0">{
                                if !i.astBuilder.HasComplete() </span><span class="cov0" title="0">{
                                        return ErrorUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">return nil</span>
                        } else<span class="cov8" title="1"> {
                                return err
                        }</span>
                }
        }
}

func (i *TokenizerStateMachine) GetCurrentMode() StateMode <span class="cov0" title="0">{
        return i.currentState.GetMode()
}</span>

func (i *TokenizerStateMachine) GetAST() ast.JsonNode <span class="cov8" title="1">{
        return i.astBuilder.GetAST()
}</span>

func (i *TokenizerStateMachine) GetASTBuilder() constructor.ASTManager <span class="cov8" title="1">{
        return i.astBuilder
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">package tokenizer

import (
        "github.com/jaksonlin/go-jsonextend/constructor"
        "github.com/jaksonlin/go-jsonextend/util"
)

type StringState struct {
        PrimitiveValueTokenStateBase
}

var _ PrimitiveValueTokenizer = &amp;StringState{}

func (i *StringState) GetMode() StateMode <span class="cov8" title="1">{
        return STRING_MODE
}</span>

func (i *StringState) ProcessData(provider constructor.TokenProvider) error <span class="cov8" title="1">{

        rs, err := provider.ReadString()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if util.RegStringWithVariable.Match(rs) </span><span class="cov8" title="1">{
                err = i.storeTokenValue(STRING_VARIABLE_MODE, rs)
        }</span> else<span class="cov8" title="1"> {
                err = i.storeTokenValue(i.GetMode(), rs)
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return i.switchState()</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package tokenizer

type TokenReader struct {
        stateMachine *TokenizerStateMachine
}

func NewTokenReader(stateMachine *TokenizerStateMachine) TokenReader <span class="cov8" title="1">{
        return TokenReader{
                stateMachine: stateMachine,
        }
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">package tokenizer

import (
        "github.com/jaksonlin/go-jsonextend/constructor"
        "github.com/jaksonlin/go-jsonextend/util"
)

type VariableState struct {
        PrimitiveValueTokenStateBase
}

var _ PrimitiveValueTokenizer = &amp;VariableState{}

func (i *VariableState) GetMode() StateMode <span class="cov8" title="1">{
        return VARIABLE_MODE
}</span>

func (i *VariableState) ProcessData(provider constructor.TokenProvider) error <span class="cov8" title="1">{

        variable, err := provider.ReadVariable()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if !util.RegStringWithVariable.Match(variable) </span><span class="cov0" title="0">{
                return ErrorExtendedVariableFormatIncorrect
        }</span>

        <span class="cov8" title="1">err = i.storeTokenValue(i.GetMode(), variable)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return i.switchState()</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package unmarshaler

import (
        "errors"
        "fmt"
)

const (
        ExpectingStructFindOthers = "expecting struct but find %s"
        VariableNotFound          = "variable value for %s not found"
        FieldNotValid             = "field not valid %s"
        KVKindNotMatch            = "expect %s as key but value is not :%#v"
)

var (
        ErrOutNotPointer                                   = errors.New("out is not pointer")
        ErrorInternalNoneResolvable                        = errors.New("expecting dependendent element to resolve")
        ErrorInternalUnsupportedMapKeyKind                 = fmt.Errorf("unsupported map key to continue")
        ErrorStringVariableNotResolveOnKeyLocation         = errors.New("object key contain string variable that has no variable value")
        ErrorInternalDependentResolverHasOnResolveLocation = errors.New("dependent value has no idex or object key set to resolve")
        ErrorPrimitiveTypeCannotResolveDependency          = errors.New("pritimive type cannot resolve dependency")
        ErrorInternalExpectingArrayLikeObject              = errors.New("expecting array like object but find others")
        ErrorInvalidUnmarshalResult                        = errors.New("invalid unmarshal result")
)

func NewErrorFieldNotValid(field string) error <span class="cov0" title="0">{
        return fmt.Errorf(FieldNotValid, field)
}</span>
func NewErrorInternalExpectingStructButFindOthers(kind string) error <span class="cov0" title="0">{
        return fmt.Errorf(ExpectingStructFindOthers, kind)
}</span>
func NewVariableNotFound(variable string) error <span class="cov0" title="0">{
        return fmt.Errorf(VariableNotFound, variable)
}</span>
func NewErrorInternalMapKeyValueKindNotMatch(kind string, value interface{}) error <span class="cov0" title="0">{
        return fmt.Errorf(KVKindNotMatch, kind, value)
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package unmarshaler

import (
        "bytes"
        "encoding/json"
        "reflect"
        "strconv"

        "github.com/jaksonlin/go-jsonextend/ast"
        "github.com/jaksonlin/go-jsonextend/util"
)

type unmarshallOptions struct {
        ensureInt     bool
        resolverStack *util.Stack[*unmarshallResolver]
        variables     map[string]interface{}
}

func NewUnMarshallOptions(variables map[string]interface{}) *unmarshallOptions <span class="cov8" title="1">{
        options := &amp;unmarshallOptions{
                ensureInt:     true,
                variables:     variables,
                resolverStack: util.NewStack[*unmarshallResolver](),
        }
        return options
}</span>

func resolveVariable(variableNode *ast.JsonExtendedVariableNode, resolver *unmarshallOptions) (interface{}, error) <span class="cov8" title="1">{

        variableValue, ok := resolver.variables[variableNode.Variable]
        if !ok </span><span class="cov0" title="0">{
                return nil, NewVariableNotFound(variableNode.Variable)
        }</span>
        <span class="cov8" title="1">return variableValue, nil</span>
}

func resolveStringVariable(stringVariable *ast.JsonExtendedStringWIthVariableNode, resolver *unmarshallOptions) ([]byte, error) <span class="cov8" title="1">{

        var resultBytes []byte = make([]byte, len(stringVariable.Value))
        copy(resultBytes, stringVariable.Value)
        for variableName, replacer := range stringVariable.Variables </span><span class="cov8" title="1">{
                variableValue, ok := resolver.variables[variableName]
                if !ok </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">variableValueBytes, err := json.Marshal(variableValue)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if variableValueBytes[0] == '"' </span><span class="cov8" title="1">{
                        if len(variableValueBytes) == 2 </span><span class="cov8" title="1">{
                                // empty string
                                resultBytes = util.RemoveBytes(resultBytes, replacer)
                        }</span> else<span class="cov8" title="1"> {
                                // remove leading tailing double quotation mark to prevent invalid string
                                variableValueBytes = variableValueBytes[1 : len(variableValueBytes)-1]
                                resultBytes = bytes.ReplaceAll(resultBytes, replacer, variableValueBytes)
                        }</span>
                } else<span class="cov0" title="0"> {
                        resultBytes = bytes.ReplaceAll(resultBytes, replacer, variableValueBytes)
                }</span>
        }
        <span class="cov8" title="1">if resultBytes[0] == '"' </span><span class="cov8" title="1">{
                if len(resultBytes) == 2 </span><span class="cov0" title="0">{
                        resultBytes = []byte("")
                }</span> else<span class="cov8" title="1"> {
                        resultBytes = resultBytes[1 : len(resultBytes)-1]
                }</span>
        }
        <span class="cov8" title="1">return resultBytes, nil</span>

}

// json input value is always float64, convert to different numeric value based on out element kind
func (resolver *unmarshallResolver) convertNumberBaseOnKind(value interface{}) interface{} <span class="cov8" title="1">{

        switch resolver.outElementKind </span>{
        case reflect.Int:<span class="cov8" title="1">
                return int(value.(float64))</span>
        case reflect.Int16:<span class="cov8" title="1">
                return int16(value.(float64))</span>
        case reflect.Int32:<span class="cov8" title="1">
                return int32(value.(float64))</span>
        case reflect.Int64:<span class="cov0" title="0">
                return int64(value.(float64))</span>
        case reflect.Int8:<span class="cov0" title="0">
                return int8(value.(float64))</span>
        case reflect.Float32:<span class="cov0" title="0">
                return float32(value.(float64))</span>
        case reflect.Float64:<span class="cov8" title="1">
                return value</span>
        case reflect.Uint:<span class="cov0" title="0">
                return uint(value.(float64))</span>
        case reflect.Uint8:<span class="cov8" title="1">
                return uint8(value.(float64))</span>
        case reflect.Uint16:<span class="cov8" title="1">
                return uint16(value.(float64))</span>
        case reflect.Uint32:<span class="cov0" title="0">
                return uint32(value.(float64))</span>
        case reflect.Uint64:<span class="cov0" title="0">
                return uint64(value.(float64))</span>
        case reflect.Interface:<span class="cov8" title="1">
                // map[xxx]interface{} keep it as it is
                parentReceiverKind := resolver.parent.ptrToActualValue.Elem().Type().Kind()
                if parentReceiverKind == reflect.Map || parentReceiverKind == reflect.Array || parentReceiverKind == reflect.Slice </span><span class="cov8" title="1">{
                        return value
                }</span>
                <span class="cov0" title="0">floatVal, ok := value.(float64)
                if ok </span><span class="cov0" title="0">{
                        if resolver.options.ensureInt </span><span class="cov0" title="0">{
                                return int(floatVal)
                        }</span> else<span class="cov0" title="0"> {
                                return floatVal
                        }</span>
                } else<span class="cov0" title="0"> {
                        return value
                }</span>
        default:<span class="cov0" title="0">
                return value</span>
        }
}

func (resolver *unmarshallResolver) createMapKeyValueByMapKeyKind(value string) (reflect.Value, error) <span class="cov8" title="1">{
        mapKeyType := resolver.ptrToActualValue.Elem().Type().Key()
        mapKeyKind := mapKeyType.Kind()
        // Helper function to convert a string to a numeric type
        convertToNumeric := func(value string) (reflect.Value, error) </span><span class="cov8" title="1">{
                switch mapKeyKind </span>{
                case reflect.Int, reflect.Int16, reflect.Int32, reflect.Int64, reflect.Int8:<span class="cov8" title="1">
                        val, err := strconv.ParseInt(value, 10, 64)
                        return reflect.ValueOf(val).Convert(mapKeyType), err</span>
                case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:<span class="cov8" title="1">
                        val, err := strconv.ParseUint(value, 10, 64)
                        return reflect.ValueOf(val).Convert(mapKeyType), err</span>
                default:<span class="cov0" title="0">
                        return reflect.Value{}, ErrorInternalUnsupportedMapKeyKind</span>
                }
        }

        // Convert string to the appropriate type based on mapKeyKind
        <span class="cov8" title="1">switch mapKeyKind </span>{
        case reflect.String:<span class="cov8" title="1">
                return reflect.ValueOf(value), nil</span>
        case reflect.Int, reflect.Int16, reflect.Int32, reflect.Int64, reflect.Int8, reflect.Float32, reflect.Float64, reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:<span class="cov8" title="1">

                if numericValue, err := convertToNumeric(value); err == nil </span><span class="cov8" title="1">{
                        return numericValue, nil
                }</span>
                <span class="cov0" title="0">return reflect.Value{}, NewErrorInternalMapKeyValueKindNotMatch(mapKeyKind.String(), value)</span>

        default:<span class="cov0" title="0">
                return reflect.Value{}, ErrorInternalUnsupportedMapKeyKind</span>
        }
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package unmarshaler

import (
        "reflect"
        "strconv"

        "github.com/jaksonlin/go-jsonextend/ast"
        "github.com/jaksonlin/go-jsonextend/interpreter"
        "github.com/jaksonlin/go-jsonextend/token"
        "github.com/jaksonlin/go-jsonextend/util"
)

var dummyMap map[string]interface{}

// we hold a pointer to these field rather than keeping the field's reflect.Value directly
// number of pointer of the original field, not including the one we create to hold the filed
type unmarshallResolver struct {
        options              *unmarshallOptions
        astNode              ast.JsonNode
        outElementKind       reflect.Kind
        arrayIndex           int
        awaitingResolveCount int
        numberOfPointer      int
        awaitingResolve      bool
        isPointerValue       bool
        IsNil                bool // when our ptrToActualValue holds a struct, there's no way to tell if we are accepting a nil for it.
        objectKey            string
        parent               *unmarshallResolver
        ptrToActualValue     reflect.Value // single ptr to no matter what actual value is (for *****int, keeps only *int to the actual value)
        fields               map[string]reflect.Value
        hasUnmarshaller      bool
}

func (resolver *unmarshallResolver) getAllFields() <span class="cov8" title="1">{
        if len(resolver.fields) &gt; 0 </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">resolver.fields = make(map[string]reflect.Value)
        s := util.NewStack[reflect.Value]()
        s.Push(resolver.ptrToActualValue.Elem())

        for </span><span class="cov8" title="1">{
                item, err := s.Pop()
                if err != nil </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">for i := 0; i &lt; item.NumField(); i++ </span><span class="cov8" title="1">{
                        fieldType := item.Type().Field(i)

                        fieldValue := item.Field(i)
                        if fieldType.Anonymous </span><span class="cov8" title="1">{
                                s.Push(fieldValue)
                                continue</span>
                        }
                        <span class="cov8" title="1">if !fieldType.IsExported() || !fieldValue.IsValid() || !fieldValue.CanSet() </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov8" title="1">resolver.fields[fieldType.Name] = fieldValue
                        jsonTag := fieldType.Tag.Get("json")
                        if jsonTag != "" </span><span class="cov8" title="1">{
                                resolver.fields[jsonTag] = fieldValue
                        }</span>

                }

        }
}

// a story for align to the go's json unmarshall is that, when the field is a pointer, and it points to a nil value, the unmarshall will resolve to a `nil pointer` not `pointer to nil value`
// therefore below is a if check to set the value to `zero` rather than `nilValue of some type`
func (resolver *unmarshallResolver) resolveSliceDependency(dependentResolver *unmarshallResolver) error <span class="cov8" title="1">{
        dependentValue := dependentResolver.restoreValue()
        if dependentResolver.IsNil || dependentResolver.isPointerValue &amp;&amp; (dependentValue.Elem().Kind() == reflect.Slice ||
                dependentValue.Elem().Kind() == reflect.Interface ||
                dependentValue.Elem().Kind() == reflect.Map) &amp;&amp; dependentValue.Elem().IsNil() </span><span class="cov8" title="1">{
                resolver.ptrToActualValue.Elem().Index(dependentResolver.arrayIndex).SetZero()
        }</span> else<span class="cov8" title="1"> {
                resolver.ptrToActualValue.Elem().Index(dependentResolver.arrayIndex).Set(dependentValue.Convert(resolver.ptrToActualValue.Elem().Type().Elem()))
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (resolver *unmarshallResolver) resolveStructDependency(dependentResolver *unmarshallResolver) error <span class="cov8" title="1">{
        field, err := resolver.getFieldByTag(dependentResolver.objectKey)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">dependentValue := dependentResolver.restoreValue()
        if dependentResolver.IsNil || dependentResolver.isPointerValue &amp;&amp; (dependentValue.Elem().Kind() == reflect.Slice ||
                dependentValue.Elem().Kind() == reflect.Interface ||
                dependentValue.Elem().Kind() == reflect.Map) &amp;&amp; dependentValue.Elem().IsNil() </span><span class="cov8" title="1">{
                field.SetZero()
        }</span> else<span class="cov8" title="1"> {
                field.Set(dependentValue.Convert(field.Type()))
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (resolver *unmarshallResolver) resolveMapDependency(dependentResolver *unmarshallResolver) error <span class="cov8" title="1">{
        key, err := resolver.createMapKeyValueByMapKeyKind(dependentResolver.objectKey)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">dependentValue := dependentResolver.restoreValue()
        if dependentResolver.isPointerValue &amp;&amp; (dependentValue.Elem().Kind() == reflect.Slice ||
                dependentValue.Elem().Kind() == reflect.Interface ||
                dependentValue.Elem().Kind() == reflect.Map) &amp;&amp; dependentValue.Elem().IsNil() </span><span class="cov8" title="1">{
                mapElementType := resolver.ptrToActualValue.Elem().Type().Elem()
                mapElementZero := reflect.Zero(mapElementType)
                resolver.ptrToActualValue.Elem().SetMapIndex(key, mapElementZero)
        }</span> else<span class="cov8" title="1"> {
                resolver.ptrToActualValue.Elem().SetMapIndex(key, dependentValue.Convert(resolver.ptrToActualValue.Elem().Type().Elem()))
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (resolver *unmarshallResolver) resolveInterfaceDependency(dependentResolver *unmarshallResolver) error <span class="cov8" title="1">{

        if dependentResolver.arrayIndex != -1 </span><span class="cov8" title="1">{ //interface holding slice
                return resolver.resolveSliceDependency(dependentResolver)
        }</span> else<span class="cov8" title="1"> {
                if len(dependentResolver.objectKey) &gt; 0 </span><span class="cov8" title="1">{ // interface holding map
                        return resolver.resolveMapDependency(dependentResolver)
                }</span> else<span class="cov0" title="0"> { // we need array index or key to resolve the location of the dependent Value
                        return ErrorInternalDependentResolverHasOnResolveLocation
                }</span>
        }

}
func (resolver *unmarshallResolver) resolveDependency(dependentResolver *unmarshallResolver) error <span class="cov8" title="1">{
        resolver.awaitingResolveCount -= 1
        if resolver.outElementKind == reflect.Array || resolver.outElementKind == reflect.Slice </span><span class="cov8" title="1">{

                return resolver.resolveSliceDependency(dependentResolver)

        }</span> else<span class="cov8" title="1"> if resolver.outElementKind == reflect.Struct </span><span class="cov8" title="1">{

                return resolver.resolveStructDependency(dependentResolver)

        }</span> else<span class="cov8" title="1"> if resolver.outElementKind == reflect.Map </span><span class="cov8" title="1">{

                return resolver.resolveMapDependency(dependentResolver)

        }</span> else<span class="cov8" title="1"> if resolver.outElementKind == reflect.Interface </span><span class="cov8" title="1">{
                return resolver.resolveInterfaceDependency(dependentResolver)
        }</span> else<span class="cov0" title="0"> {
                return ErrorPrimitiveTypeCannotResolveDependency
        }</span>

}

func (resolver *unmarshallResolver) setValue(value interface{}) <span class="cov8" title="1">{
        if value == nil </span><span class="cov8" title="1">{
                nilValue := reflect.Zero(resolver.ptrToActualValue.Elem().Type())
                resolver.ptrToActualValue.Elem().Set(nilValue)
        }</span> else<span class="cov8" title="1"> {
                resolver.ptrToActualValue.Elem().Set(reflect.ValueOf(value).Convert(resolver.ptrToActualValue.Elem().Type()))
        }</span>
}

// return the actual reflect.Value in the resolver, the resolver is desinged to hold a pointer to anything it keeps
// when the actual field is pointer type, you need a pointer to the actual field to set its Elem to the retrun value from this func
func (resolver *unmarshallResolver) restoreValue() reflect.Value <span class="cov8" title="1">{
        if !resolver.isPointerValue </span><span class="cov8" title="1">{
                return resolver.ptrToActualValue.Elem() // remove the pointer we add (newUnmarshallResolver)
        }</span> else<span class="cov8" title="1"> {
                // the field is *interface{}
                if resolver.outElementKind == reflect.Interface </span><span class="cov8" title="1">{
                        var value interface{} = resolver.ptrToActualValue.Elem().Interface()
                        resolver.ptrToActualValue = reflect.ValueOf(&amp;value)
                }</span>
                // actual value
                <span class="cov8" title="1">if resolver.numberOfPointer == 1 </span><span class="cov8" title="1">{
                        return resolver.ptrToActualValue // just use our value holder
                }</span>
                <span class="cov8" title="1">var resultPtr = resolver.ptrToActualValue // what we hold *someStruct, actual ***int (isPointerValue=true, numberOfPointer=3), then we start from *someStruct
                var tmpPtr reflect.Value
                for i := resolver.numberOfPointer; i &gt; 1; i-- </span><span class="cov8" title="1">{
                        tmpPtr = reflect.New(resultPtr.Type())
                        tmpPtr.Elem().Set(resultPtr)
                        resultPtr = tmpPtr
                }</span>
                <span class="cov8" title="1">return resultPtr</span> // when the original field is ***int, and we create the ***int, you need to take the address of the origianl field to set this value in.(use a ****int to set its element to this func's return value)
        }
}

func (resolver *unmarshallResolver) bindObjectParent(key string, parent *unmarshallResolver) <span class="cov8" title="1">{
        resolver.objectKey = key
        resolver.parent = parent
        parent.awaitingResolveCount += 1
        parent.awaitingResolve = true
}</span>
func (resolver *unmarshallResolver) bindArrayLikeParent(index int, parent *unmarshallResolver) <span class="cov8" title="1">{
        resolver.arrayIndex = index
        resolver.parent = parent
        parent.awaitingResolveCount += 1
        parent.awaitingResolve = true
}</span>

func createPtrToSliceValue(nodeToWork ast.JsonNode, someOutType reflect.Type) (reflect.Value, ast.JsonNode, error) <span class="cov8" title="1">{
        var isNil = nodeToWork.GetNodeType() == ast.AST_NULL
        numberOfElement := 0
        var convertedNode ast.JsonNode = nil
        if !isNil </span><span class="cov8" title="1">{
                // in golang json processing for slice of Uint8 it will convert to base64
                if someOutType.Elem().Kind() == reflect.Uint8 &amp;&amp; nodeToWork.GetNodeType() == ast.AST_STRING </span><span class="cov8" title="1">{
                        n, err := nodeToWork.(*ast.JsonStringNode).ToArrayNode()
                        if err != nil </span><span class="cov0" title="0">{
                                return reflect.Value{}, nil, err
                        }</span>
                        <span class="cov8" title="1">numberOfElement = n.Length()
                        convertedNode = n</span>
                } else<span class="cov8" title="1"> {
                        n, ok := nodeToWork.(*ast.JsonArrayNode)
                        if !ok </span><span class="cov0" title="0">{
                                return reflect.Value{}, nil, ErrorInternalExpectingArrayLikeObject
                        }</span>
                        <span class="cov8" title="1">numberOfElement = n.Length()
                        convertedNode = n</span>
                }
        }

        <span class="cov8" title="1">sliceType := reflect.SliceOf(someOutType.Elem())
        sliceValue := reflect.MakeSlice(sliceType, numberOfElement, numberOfElement) // use index to manipulate the slice
        ptrToActualValue := reflect.New(sliceValue.Type())
        ptrToActualValue.Elem().Set(sliceValue)
        return ptrToActualValue, convertedNode, nil</span>
}

func createPtrToArrayValue(nodeToWork ast.JsonNode, someOutType reflect.Type) (reflect.Value, error) <span class="cov8" title="1">{
        n, ok := nodeToWork.(*ast.JsonArrayNode)
        if !ok </span><span class="cov0" title="0">{
                return reflect.Value{}, ErrorInternalExpectingArrayLikeObject
        }</span>
        <span class="cov8" title="1">numberOfElement := n.Length()
        arrayType := reflect.ArrayOf(numberOfElement, someOutType.Elem())
        ptrToActualValue := reflect.New(arrayType)
        return ptrToActualValue, nil</span>
}

func createPtrToInterfaceValue(nodeToWork ast.JsonNode, someOutType reflect.Type) (reflect.Value, error) <span class="cov8" title="1">{
        var ptrToActualValue reflect.Value
        // someField: interface{}
        if nodeToWork.GetNodeType() == ast.AST_ARRAY </span><span class="cov8" title="1">{
                numberOfElement := nodeToWork.(*ast.JsonArrayNode).Length()
                sliceType := reflect.SliceOf(reflect.TypeOf((*interface{})(nil)).Elem())
                sliceValue := reflect.MakeSlice(sliceType, numberOfElement, numberOfElement) // use index to manipulate the slice
                ptrToActualValue = reflect.New(sliceValue.Type())
                ptrToActualValue.Elem().Set(sliceValue)
        }</span> else<span class="cov8" title="1"> if nodeToWork.GetNodeType() == ast.AST_OBJECT </span><span class="cov8" title="1">{
                newMap := reflect.MakeMap(reflect.TypeOf(dummyMap))
                ptrToActualValue = reflect.New(newMap.Type())
                ptrToActualValue.Elem().Set(newMap)
        }</span> else<span class="cov8" title="1"> {
                ptrToActualValue = reflect.New(someOutType)
                ptrToActualValue.Elem().Set(reflect.Zero(someOutType))
        }</span>
        <span class="cov8" title="1">return ptrToActualValue, nil</span>
}

func newUnmarshallResolver(
        node ast.JsonNode,
        outType reflect.Type,
        options *unmarshallOptions) (*unmarshallResolver, error) <span class="cov8" title="1">{
        var nodeToWork ast.JsonNode = node
        someOutType := outType
        numberOfPointer := 0
        var elementKind reflect.Kind

        isPointerValue := someOutType.Kind() == reflect.Pointer
        for someOutType.Kind() == reflect.Pointer </span><span class="cov8" title="1">{
                someOutType = someOutType.Elem()
                numberOfPointer += 1
        }</span>
        <span class="cov8" title="1">var ptrToActualValue reflect.Value
        // use a pointer to hold no matter what it is inside
        switch someOutType.Kind() </span>{
        case reflect.Slice:<span class="cov8" title="1">
                ptr, convertedNode, err := createPtrToSliceValue(nodeToWork, someOutType)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if convertedNode != nil </span><span class="cov8" title="1">{
                        nodeToWork = convertedNode
                }</span>
                <span class="cov8" title="1">ptrToActualValue = ptr
                elementKind = reflect.Slice</span>
        case reflect.Array:<span class="cov8" title="1">
                ptr, err := createPtrToArrayValue(nodeToWork, someOutType)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">ptrToActualValue = ptr
                elementKind = reflect.Array</span>
        case reflect.Map:<span class="cov8" title="1">
                newMap := reflect.MakeMap(someOutType)
                ptrToActualValue = reflect.New(newMap.Type())
                ptrToActualValue.Elem().Set(newMap)
                elementKind = reflect.Map</span>
        case reflect.Struct:<span class="cov8" title="1">
                ptrToActualValue = reflect.New(someOutType) //*Struct
                elementKind = reflect.Struct</span>
        case reflect.Interface:<span class="cov8" title="1">
                // someField: interface{}
                ptr, err := createPtrToInterfaceValue(nodeToWork, someOutType)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">ptrToActualValue = ptr
                elementKind = reflect.Interface</span>
        default:<span class="cov8" title="1"> // primitives
                ptrToActualValue = reflect.New(someOutType)
                ptrToActualValue.Elem().Set(reflect.Zero(someOutType))
                elementKind = someOutType.Kind()</span>
        }
        // we only support pointer receiver unmarshaler, therefore pass in the Pointer not the pointer to element
        <span class="cov8" title="1">hasUnmarshaller := implementsUnmarshaler(ptrToActualValue.Type())

        base := &amp;unmarshallResolver{
                options:              options,
                astNode:              nodeToWork,
                ptrToActualValue:     ptrToActualValue,
                awaitingResolveCount: 0,
                awaitingResolve:      false,
                parent:               nil,
                arrayIndex:           -1,
                numberOfPointer:      numberOfPointer,
                isPointerValue:       isPointerValue,
                outElementKind:       elementKind,
                IsNil:                nodeToWork.GetNodeType() == ast.AST_NULL,
                hasUnmarshaller:      hasUnmarshaller,
        }
        return base, nil</span>
}
func implementsUnmarshaler(t reflect.Type) bool <span class="cov8" title="1">{
        // Check for pointer type if the provided type isn't a pointer.
        if t.Kind() != reflect.Ptr </span><span class="cov0" title="0">{
                t = reflect.PtrTo(t)
        }</span>

        <span class="cov8" title="1">method, ok := t.MethodByName("UnmarshalJSON")
        if !ok </span><span class="cov8" title="1">{
                return false
        }</span>

        // Check method signature
        <span class="cov8" title="1">if method.Type.NumIn() != 2 || method.Type.In(1) != reflect.TypeOf([]byte{}) || method.Type.NumOut() != 1 || method.Type.Out(0) != reflect.TypeOf((*error)(nil)).Elem() </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">return true</span>
}

var _ ast.JsonVisitor = &amp;unmarshallResolver{}

func (resolver *unmarshallResolver) resolveByCustomizeObjectUnmarshal(node ast.JsonNode) error <span class="cov8" title="1">{

        unmarshalMethod := resolver.ptrToActualValue.MethodByName("UnmarshalJSON")

        payload, err := interpreter.InterpretAST(node, resolver.options.variables)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">result := unmarshalMethod.Call([]reflect.Value{reflect.ValueOf(payload)})
        unmarshalError := result[0].Interface()
        if unmarshalError == nil </span><span class="cov8" title="1">{
                return resolver.resolve()
        }</span> else<span class="cov0" title="0"> {
                if err, ok := unmarshalError.(error); ok </span><span class="cov0" title="0">{
                        return err
                }</span> else<span class="cov0" title="0"> {
                        return ErrorInvalidUnmarshalResult
                }</span>
        }
}

func (resolver *unmarshallResolver) VisitArrayNode(node *ast.JsonArrayNode) error <span class="cov8" title="1">{
        // fill the values in the reflection.Value
        if resolver.hasUnmarshaller </span><span class="cov0" title="0">{
                return resolver.resolveByCustomizeObjectUnmarshal(node)
        }</span>
        <span class="cov8" title="1">for i := len(node.Value) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                resolver, err := resolver.createArrayElementResolver(i, node.Value[i])
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">resolver.options.resolverStack.Push(resolver)</span>
        }
        <span class="cov8" title="1">return resolver.resolve()</span>

}

// this is only visit from VisitObjectNode, it does not resolve any value, no need to check unmarshaler call
func (resolver *unmarshallResolver) VisitKeyValuePairNode(node *ast.JsonKeyValuePairNode) error <span class="cov8" title="1">{

        key, err := resolver.processKVKeyNode(node.Key)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">newResolver, err := resolver.processKVValueNode(key, node.Value)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">resolver.options.resolverStack.Push(newResolver)

        return nil</span>
}

func (resolver *unmarshallResolver) VisitObjectNode(node *ast.JsonObjectNode) error <span class="cov8" title="1">{
        if resolver.hasUnmarshaller </span><span class="cov8" title="1">{
                return resolver.resolveByCustomizeObjectUnmarshal(node)
        }</span>
        // fill the values in the reflection.Value
        <span class="cov8" title="1">for i := len(node.Value) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                kvNode := node.Value[i]
                if err := kvNode.Visit(resolver); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return resolver.resolve()</span>
}

func (resolver *unmarshallResolver) VisitBooleanNode(node *ast.JsonBooleanNode) error <span class="cov8" title="1">{
        if resolver.hasUnmarshaller </span><span class="cov8" title="1">{
                if node.Value </span><span class="cov0" title="0">{
                        return resolver.resolveByCustomizePrimitiveUnmarshal(token.TrueBytes)
                }</span> else<span class="cov8" title="1"> {
                        return resolver.resolveByCustomizePrimitiveUnmarshal(token.FalseBytes)
                }</span>
        }
        <span class="cov8" title="1">resolver.setValue(node.Value)
        return resolver.resolve()</span>
}

func (resolver *unmarshallResolver) VisitNullNode(node *ast.JsonNullNode) error <span class="cov8" title="1">{
        if resolver.hasUnmarshaller </span><span class="cov8" title="1">{
                // fast unmarshal instead of using interpreter for primitive values
                return resolver.resolveByCustomizePrimitiveUnmarshal(token.NullBytes)
        }</span>
        <span class="cov8" title="1">resolver.setValue(node.Value)
        return resolver.resolve()</span>
}

func (resolver *unmarshallResolver) VisitNumberNode(node *ast.JsonNumberNode) error <span class="cov8" title="1">{
        if resolver.hasUnmarshaller </span><span class="cov8" title="1">{
                // fast unmarshal instead of using interpreter for primitive values
                numStr := strconv.FormatFloat(node.Value, 'f', -1, 64)
                return resolver.resolveByCustomizePrimitiveUnmarshal([]byte(numStr))
        }</span>
        <span class="cov8" title="1">realValue := resolver.convertNumberBaseOnKind(node.Value)
        resolver.setValue(realValue)
        return resolver.resolve()</span>
}

// this is design to call the customize unmarshaler and `resolve` the resolver
func (resolver *unmarshallResolver) resolveByCustomizePrimitiveUnmarshal(payload []byte) error <span class="cov8" title="1">{
        // fast unmarshal instead of using interpreter for primitive values
        unmarshalMethod := resolver.ptrToActualValue.MethodByName("UnmarshalJSON")
        if unmarshalMethod.IsValid() </span><span class="cov8" title="1">{
                result := unmarshalMethod.Call([]reflect.Value{reflect.ValueOf(payload)})
                if unmarshalErr, ok := result[0].Interface().(error); ok </span><span class="cov0" title="0">{
                        if unmarshalErr != nil </span><span class="cov0" title="0">{
                                return unmarshalErr
                        }</span>
                }
                <span class="cov8" title="1">return resolver.resolve()</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (resolver *unmarshallResolver) VisitStringNode(node *ast.JsonStringNode) error <span class="cov8" title="1">{
        if resolver.hasUnmarshaller </span><span class="cov8" title="1">{
                return resolver.resolveByCustomizePrimitiveUnmarshal(node.Value)
        }</span>
        <span class="cov8" title="1">valueToUnmarshal := util.RepairUTF8(string(node.GetValue()))
        resolver.setValue(valueToUnmarshal)
        return resolver.resolve()</span>
}

func (resolver *unmarshallResolver) VisitStringWithVariableNode(node *ast.JsonExtendedStringWIthVariableNode) error <span class="cov8" title="1">{
        if resolver.hasUnmarshaller </span><span class="cov0" title="0">{
                valueToUnmarshal := util.RepairUTF8(string(node.GetValue()))
                return resolver.resolveByCustomizePrimitiveUnmarshal([]byte(valueToUnmarshal))
        }</span>
        <span class="cov8" title="1">result, err := resolveStringVariable(node, resolver.options)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">valueToSet := util.RepairUTF8(string(result))
        resolver.setValue(valueToSet)
        return resolver.resolve()</span>
}

func (resolver *unmarshallResolver) VisitVariableNode(node *ast.JsonExtendedVariableNode) error <span class="cov8" title="1">{
        if resolver.hasUnmarshaller </span><span class="cov0" title="0">{
                return resolver.resolveByCustomizePrimitiveUnmarshal(node.Value)
        }</span>
        <span class="cov8" title="1">result, err := resolveVariable(node, resolver.options)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if result != nil &amp;&amp; reflect.TypeOf(result).Kind() == reflect.String </span><span class="cov8" title="1">{
                valueToSet := util.RepairUTF8(result.(string))
                resolver.setValue(valueToSet)
        }</span> else<span class="cov8" title="1"> {
                resolver.setValue(result)
        }</span>
        <span class="cov8" title="1">return resolver.resolve()</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package unmarshaler

import (
        "reflect"

        "github.com/jaksonlin/go-jsonextend/ast"
        "github.com/jaksonlin/go-jsonextend/util"
)

func (resolver *unmarshallResolver) processKVKeyNode(node ast.JsonStringValueNode) (string, error) <span class="cov8" title="1">{
        var key string = node.GetValue()
        if node.GetNodeType() == ast.AST_STRING_VARIABLE </span><span class="cov8" title="1">{
                resultBytes, err := resolveStringVariable(node.(*ast.JsonExtendedStringWIthVariableNode), resolver.options)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov8" title="1">if util.RegStringWithVariable.Match(resultBytes) </span><span class="cov0" title="0">{
                        return "", ErrorStringVariableNotResolveOnKeyLocation
                }</span>
                <span class="cov8" title="1">key = string(resultBytes)</span>
        }
        <span class="cov8" title="1">return key, nil</span>
}

func (resolver *unmarshallResolver) getFieldByTag(objKey string) (reflect.Value, error) <span class="cov8" title="1">{
        resolver.getAllFields()
        fieldInfo, ok := resolver.fields[objKey]
        if !ok </span><span class="cov0" title="0">{
                return reflect.Value{}, NewErrorFieldNotValid(objKey)
        }</span>
        <span class="cov8" title="1">return fieldInfo, nil</span>
}

// create resolver to resolving the things in kv's value
func (resolver *unmarshallResolver) processKVValueNode(key string, valueNode ast.JsonNode) (*unmarshallResolver, error) <span class="cov8" title="1">{
        // create child resolver by data type
        var childElementType reflect.Type = resolver.ptrToActualValue.Elem().Type()
        // can only be map/struct to hold the kv

        if childElementType.Kind() == reflect.Map </span><span class="cov8" title="1">{

                childElementType = resolver.ptrToActualValue.Type().Elem().Elem()

        }</span> else<span class="cov8" title="1"> if childElementType.Kind() == reflect.Struct </span><span class="cov8" title="1">{

                fieldInfo, err := resolver.getFieldByTag(key) // struct field
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">childElementType = fieldInfo.Type()</span>

        } else<span class="cov0" title="0"> {
                return nil, NewErrorInternalExpectingStructButFindOthers(childElementType.Kind().String())
        }</span>

        // 2. create the collection's reflection value representative
        <span class="cov8" title="1">newResolver, err := newUnmarshallResolver(valueNode, childElementType, resolver.options)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 3. create relation
        <span class="cov8" title="1">newResolver.bindObjectParent(key, resolver)

        return newResolver, nil</span>
}

func (resolver *unmarshallResolver) createArrayElementResolver(index int, node ast.JsonNode) (*unmarshallResolver, error) <span class="cov8" title="1">{
        // root: slice, array, *array

        // 1. get the keys coresponding value type
        var childElementType reflect.Type = resolver.ptrToActualValue.Elem().Type()

        if resolver.ptrToActualValue.Elem().Kind() == reflect.Slice || resolver.ptrToActualValue.Elem().Kind() == reflect.Array </span><span class="cov8" title="1">{

                childElementType = resolver.ptrToActualValue.Elem().Type().Elem()

        }</span>

        // 2. create the collection's reflection value representative
        <span class="cov8" title="1">newResolver, err := newUnmarshallResolver(node, childElementType, resolver.options)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 3. create relation
        <span class="cov8" title="1">newResolver.bindArrayLikeParent(index, resolver)

        return newResolver, nil</span>
}

func (resolver *unmarshallResolver) resolve() error <span class="cov8" title="1">{
        // no parent, no need to enclose
        if resolver.parent == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        // have unresolve child item, cannot enclose now
        <span class="cov8" title="1">if resolver.awaitingResolveCount &gt; 0 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return resolver.parent.resolveDependency(resolver)</span>
}

func (resolver *unmarshallResolver) process() error <span class="cov8" title="1">{
        node := resolver.astNode
        return node.Visit(resolver)
}</span>

func UnmarshallAST(node ast.JsonNode, variables map[string]interface{}, out interface{}) error <span class="cov8" title="1">{
        // deep first traverse the AST
        valueItem := reflect.ValueOf(out)
        if valueItem.Kind() != reflect.Pointer || valueItem.IsNil() </span><span class="cov0" title="0">{
                return ErrOutNotPointer
        }</span>

        <span class="cov8" title="1">options := NewUnMarshallOptions(variables)
        traverseStack := options.resolverStack
        resolver, err := newUnmarshallResolver(node, valueItem.Type(), options)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">traverseStack.Push(resolver)

        for </span><span class="cov8" title="1">{
                resolver, err := traverseStack.Peek()
                if err != nil </span><span class="cov8" title="1">{
                        break</span>
                }
                // no dependency waiting
                <span class="cov8" title="1">if !resolver.awaitingResolve </span><span class="cov8" title="1">{
                        // process elements
                        err = resolver.process()
                        if err != nil </span><span class="cov0" title="0">{
                                if err != util.ErrorEndOfStack </span><span class="cov0" title="0">{
                                        return err
                                }</span> else<span class="cov0" title="0"> {
                                        break</span>
                                }
                        }
                        // if there's no awaiting dependency, pop
                        <span class="cov8" title="1">if !resolver.awaitingResolve </span><span class="cov8" title="1">{
                                traverseStack.Pop() // no awaiting resolve items pop
                        }</span>
                } else<span class="cov8" title="1"> {
                        // when the dependecies are resolved, enclose and pop
                        if resolver.awaitingResolveCount != 0 </span><span class="cov0" title="0">{
                                return ErrorInternalNoneResolvable
                        }</span>
                        <span class="cov8" title="1">if err := resolver.resolve(); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">traverseStack.Pop()</span>
                }

        }
        <span class="cov8" title="1">actualValue := resolver.restoreValue().Elem()
        valueItem.Elem().Set(actualValue.Convert(valueItem.Elem().Type()))
        return nil</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package util

import (
        "bytes"
        "regexp"
        "unicode/utf8"
)

var RegStringWithVariable regexp.Regexp = *regexp.MustCompile(`\$\{([a-zA-Z\_]+\w*?)\}`)

func IsSpaces(b byte) bool <span class="cov8" title="1">{
        return b == 0x20 || (b &lt; 0x0E &amp;&amp; b &gt; 0x08)
}</span>

func IsNumberStartingCharacter(b byte) bool <span class="cov8" title="1">{
        return (b &gt; 0x2F &amp;&amp; b &lt; 0x3A) || b == '-'
}</span>

func RemoveBytes(b []byte, b2remove []byte) []byte <span class="cov8" title="1">{
        parts := bytes.Split(b, b2remove)
        if len(parts) == 1 </span><span class="cov0" title="0">{
                return b
        }</span>
        <span class="cov8" title="1">var rebuilt []byte
        for _, part := range parts </span><span class="cov8" title="1">{
                rebuilt = append(rebuilt, part...)
        }</span>
        <span class="cov8" title="1">return rebuilt</span>
}

func RepairUTF8(s string) string <span class="cov8" title="1">{
        if utf8.ValidString(s) </span><span class="cov8" title="1">{
                return s // Already valid UTF-8.
        }</span>

        <span class="cov0" title="0">var repaired []rune
        for len(s) &gt; 0 </span><span class="cov0" title="0">{
                r, size := utf8.DecodeRuneInString(s)
                repaired = append(repaired, r)
                s = s[size:]
        }</span>

        <span class="cov0" title="0">return string(repaired)</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package util

import (
        "errors"
)

const (
        EMPTY_STACK = "Empty Stack"
)

var ErrorEndOfStack = errors.New("end of stack")

type Stack[T any] struct {
        s []T
}

func (s *Stack[T]) Length() int <span class="cov8" title="1">{
        return len(s.s)
}</span>
func (s *Stack[T]) GetSlice() []T <span class="cov0" title="0">{
        return s.s
}</span>

func NewStack[T any]() *Stack[T] <span class="cov8" title="1">{
        return &amp;Stack[T]{make([]T, 0)}
}</span>

func (s *Stack[T]) Push(v T) <span class="cov8" title="1">{
        s.s = append(s.s, v)
}</span>

func (s *Stack[T]) Pop() (T, error) <span class="cov8" title="1">{
        l := len(s.s)
        if l == 0 </span><span class="cov8" title="1">{
                return *new(T), ErrorEndOfStack
        }</span>

        <span class="cov8" title="1">res := s.s[l-1]
        s.s = s.s[:l-1]
        return res, nil</span>
}

func (s *Stack[T]) Peek() (T, error) <span class="cov8" title="1">{
        l := len(s.s)
        if l == 0 </span><span class="cov8" title="1">{
                return *new(T), ErrorEndOfStack
        }</span>
        <span class="cov8" title="1">return s.s[l-1], nil</span>
}

func (s *Stack[T]) PushElements(v []T) <span class="cov0" title="0">{
        s.s = append(s.s, v...)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
